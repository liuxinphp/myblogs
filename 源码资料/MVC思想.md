# **MVC思想**



> **思考**：PHP学习开始，我们的代码先是出现在HTML混合状态下，然后慢慢的独立出来，后来又将PHP代码再分离到不同的脚本中，互相加载调用彼此。这个里面的逻辑到底是什么样子的？

> **引入**：其实从实现业务功能而言，哪种模式都可以。但是项目开发往往属于团队协作，讲究团队配合以及后期代码的可维护性，从而就出现了代码分类、分文件的做法。对于代码的发展，我们有不同的定位，每种方式也都有其独特的优缺点。



## **1. 代码发展历程【了解】**



> **定义**：代码发展历程其实也是随着软件工程思想的成熟，并依赖硬件水平的提高而形成的自然过渡。在过渡过程中主要形成了以下几种开发方式。

1. 混编模式：即PHP代码与HTML是互相嵌入的

* 优点：服务器解析效率最高
* 缺点：代码复用性极低、视觉效果差、可维护性差

2. 模板技术：将PHP代码与HTML代码进行分离，PHP中实现业务逻辑和数据处理，HTML中只进行数据的显示

* 优点：代码复用性增强、视觉效果增强、前后端分离有助于前后端开发工程师维护
* 缺点：小项目开发效率降低、服务器解析效率降低

3. MVC思想：在模板技术之上，将PHP代码的业务逻辑处理部分和数据操作部分继续分离，独立维护

* 优点：分类好管理、视觉效果好、维护性强
* 缺点：前期开发效率低、服务器解析效率最低

4. 发展历程

* 混编模式是PHP早期设计的模式，当时要完成的内容很简单（个人博客），硬件效率也不是那么高（网络传输效率不高）
* PHP逐渐被开发人员所喜爱，开始进行一些较大项目，为了方便维护，就进行了前后台分离，出现了模板技术
* 面向对象开发作为编程主流，PHP也朝着这个方向发展，作为大型项目的支撑，需要有更好的代码结构，实现代码的复用和后续维护，因此出现了MVC思想



> **总结**

1. PHP随着时代的发展，经历了三个阶段：混编阶段、模板技术（前后端分离）和MVC思想设计
2. 每个阶段都有彼此的优缺点
3. MVC思想符合人类思维模式，缺点是服务器解析成本高，不过随着硬件的发展和网络的发展，这些效率相对开发维护而言，已经不足考虑



***



> **思考**：MVC思想分离代码的逻辑是什么？为什么可以实现代码的复用呢？

> **引入**：MVC思想代码分离的逻辑就是“专人专事”，该谁做的事就归结到某个具体的“对象”来完成。一旦某些功能已经出现过，那么后续所有需要使用该功能的其他文件就可以直接使用（面向对象继承）。



## **2.  MVC思想介绍【掌握】**



> **定义**：MVC思想，并非一种特定的技术，而是一种基于**面向对象思想**形成的有利于代码复用的设计行为。基于MVC思想开发的代码更加符合人类行为特性，也更利于后期项目维护和扩展。

1. MVC是一种缩写结构

* M：Model，模型，专门负责数据操作，针对数据库部分的代码。一个模型（类）针对一张数据表
* V：View，视图，专门负责结果数据渲染（HTML+CSS+Javascript）。
* C：Controller，控制器，负责所有的业务处理。一个控制器控制（类）一类业务

2. MVC思想设计下的代码工作逻辑

* 用户发起请求：请求控制器C
* 控制器处理业务逻辑
  * 遇到数据处理需求：请求模型M实现数据库操作
  * 处理结果展示：调用视图V显示渲染数据

```sequence
浏览器->服务器: 发送请求
服务器->控制器: 控制器接收请求
note right of 控制器:控制器接收请求\n业务处理
控制器-->模型:数据处理需求
note right of 模型:数据库操作
模型-->控制器:返回数据
控制器-->视图:数据渲染处理
note right of 视图:渲染数据
视图-->控制器:返回渲染结果
控制器->服务器:控制器处理完毕\n交给服务器
服务器->浏览器:服务器返回执行结果
note left of 浏览器:解析渲染后\n的数据结果



```

3. 在面向对象的MVC中，因为模型是针对具体数据表，意味着每个模型都需要进行数据库的连接操作，这个时候通常会设计一层专门负责数据库初始化部分的（类似二次封装PDO，没有具体数据业务，只负责数据库底层操作），我们把这层叫做DAO（Data Access Object）数据访问对象

![MVC设计思想](效果图\MVC设计思想.gif)





> **总结**

1. MVC并非一种技术，而是一种代码分离设计的思想
2. MVC会让代码运行变慢，但是基于现在硬件性能，这个效率影响一般可以忽略
3. MVC是由控制器、模型、视图三部分组成

* 控制器：负责所有事务处理，也包括调用模型和视图
* 模型：只负责数据逻辑处理，包括操作数据库
* 视图：只负责数据渲染，主要是HTML+CSS+Javascript

4. 通常情况下，面向对象中还会在模型和数据库之间增加一层DAO来专门负责数据库底层实现



***



> **思考**：在实际开发中，MVC思想到底该如何运用呢？

> **引入**：其实，MVC思想的使用是很类似我们的生活的，所以在使用起来，是比较容易上手的。主要要考虑如何区分业务，以及识别业务中数据逻辑部分。



## **3. MVC代码设计【掌握】**



> **定义**：MVC代码设计，就是当一个系统要实现时，我们如何区分哪里该由控制器处理，哪里该由模型处理，最后如何在视图中渲染。

1. 区分业务设计控制器：根据业务相关性和相似性，将对应业务划分到一起，由一个控制器来实现，控制器设计成类，不同方法代表不同业务处理，如后台的注册、登录以及注销这块，都属于权限功能，可以划分到一起；控制器可以区分前后台（看系统需求是否需要区分），可以增加相应的命名空间；为了后期代码好维护，可以增加控制器后缀controller

```PHP
//后台权限控制器
//命名空间
namespace admin\controller;			//表明是后台代码，而且是控制器

class PrivilegeController{
    //一个方法实现一个小业务：一次请求完成用户一次需求
    public function login(){
        //可以是单独的获取登录表单，也可以在里面使用判定方式实现获取表单和完成登录两个功能
        if(isset($_POST['username'])){
            //用户有提交用户名：说明当前是要完成登录功能
            //代码实现登录功能：调用模型
        }else{
            //没有提交表单：说明是用来获取登录表单
            //加载登录视图（HTML）
        }
    }
    
    //注册功能
    public function register(){
        //实现注册功能（注册和加载注册表单）
    }
}
```

2. 区分数据增加模型：模型的设计通常是基于表的，即一张表会有一个对应的模型类，对应表的所有操作（增删改查）都会有当前模型类来实现，所有的SQL指令都是封装到当前模型中。与控制器一样，也应该增加相应的 命名空间，以及模型后缀model

```PHP
//后台管理员模型
namespace admin\model;

class AdminModel{
    //模型针对表，所以通常会在模型中增加一个表名：因为所有方法都会涉及到SQL，便于以后维护
    protected $table = 'admin';
    
    //根据用户名获取用户信息
    public function getUserinfoByUsername($username){
        //组织SQL
        $sql = "select * from {$this->table} where username = '{$username}'";
        
        //执行：通常调用DAO执行即可
        
        //返回数据执行结果
        return $res;
    }
    
    //获取所有用户信息
    public function getAll(){
        $sql = "select * from {$this->table}";
        //调用DAO执行SQL并返回结果
        return $users;
    }
}
```

3. 选择合适视图：视图通常是前端提供好，后端人员要做的就是如何去在视图中增加对应的PHP输出指令，将数据放到合适的位置：假设当前获取的是用户的登录信息

```php+HTML
<html>
    <header></header>
    <body>
        <table>
            <tr><td>序号</td><td>用户名</td><td></td>上次登录时间</td></tr>
    		<?php foreach($logininfo as $k => $info):?>
    		<tr>
                <td><?php echo $k+1;?></td>
                <td><?php echo $info['username'];?></td>
                <td><?php echo $info['login_time'];?></td>
    		</tr>
    		<?php endforeach;?>
        </table>
    </body>
</html>
```

4. 在实际开发项目中，会有很多控制器，每个控制器本质要做的事情都差不多，只是具体的业务逻辑不一样。此时就会出现很多类似的功能，如操作成功、失败、页面找不到等等，此时如果在所有控制器中都去写对应的方法，那么肯定是有资源浪费的，此时就可以从这些控制器中抽离一部分公共代码出来，形成父类，从而实现代码的复用

```PHP
//父类控制器：通常在核心中
namespace core;

class Controller{
    //公共代码
    public function __construct(){
        //控制器的初始化操作
    }
    protected function success(){
        //成功操作
    }
    
    protected function error(){
        //失败操作
    }
    
    //......
}
```

```PHP
//子类控制器继承父类控制器
namespace admin\controller;
use \Core\Controller;				//引入父类

class IndexController extends Controller{
    //业务方法
    public function index(){
        //调用父类公共方法
        $this->success();
    }
}
```

5. 同样的，模型是针对一张表一个模型，而每个模型都需要利用DAO来实现数据库的底层操作，以二次封装的PDO为例，所有的模型类都需要在构造方法中实现PDO的实例化，而且还会有很多公共的功能，如查询全部、通过ID进行查询等常用方法，此时也可以将模型的公共部分抽离出来，形成父类，而其他模型类只需要继承该类即可

```PHP
//父类公共模型
namespace core;

class Model{
    //实现DAO的初始化：通常使用构造方法，因为所有模型子类继承该类都会先调用构造方法
    public function __construct(){
       //实现DAO类的初始化，完成数据库初始化操作：通常是用对象保存得到的DAO对象 
       $this->dao = new DAO();		//假定操作
    }
    
    //获取所有数据
    public function getAll(){
        $sql = "select * from {$this->table}";	//子类模型中有受保护的属性$table，父类也可以调用（最终是子类调用该方法）
        //执行完成，返回结果即可
        return $rows;
    }
}
```

```PHP
//子类模型继承父类
namespace admin\model;
use \Core\Model;

class UserModel extends Model{
    //表名属性
    protected $table = 'user';
}

//当前类没有自己的构造方法，意味着实例化UserModel的时候会调用继承自Model类的构造方法，从而实现DAO的实例化，也就是说实例化的UserModel对象，可以直接调用父类的getAll方法来实现数据库的操作
```



> **总结**

1. MVC思想的指导思路

* 区分业务：确定是共用还是单独创建控制器
* 区分数据：确定是属于控制器还是应该创建模型

2. MVC思想中，会存在很多重复的内容，此时就需要我们进行抽象化

* 公共控制器代码：父类控制器
* 公共模型代码：父类模型



***



> **思考**：按照MVC思想设计的项目，所有的请求都是请求C控制器，此时用户浏览器发来的请求就不会请求其他任何PHP文件了，对吗？

> **引入**：因为MVC思想规定，所有的请求都是用控制器来处理，因此用户的任何请求，都会是由控制器来进行处理。而其他的文件，如模型和视图文件，也都是通过控制器来直接或者间接调用的，我们把这种设计思路称之为`单一入口`，但是其实本质在进入控制器之前，还有好多初始化的操作需要实现，因此我们在MVC实现的基础上，规定其他文件的访问方式，这就是`项目单一入口`



## **4. 项目单一入口【掌握】**



> **定义**：单一入口，是指一类业务会统一请求一个对应的控制器，所有的请求都是由控制器来处理；项目单一入口是指，所有的请求都只请求一个入口文件，其他的所有代码的调用执行，都是由该入口文件来管理。

1. 项目单一入口是指在基于MVC设计情况下，在进入MVC之前，由一个统一的入口文件来进行管理，所有的用户（浏览器）请求都只允许访问入口文件

```sequence
浏览器->服务器:发起请求
服务器->入口文件\nindex.php:统一由入口文件处理\n通常是index.php
note right of 入口文件\nindex.php:入口文件开始\n分发控制器
入口文件\nindex.php-->控制器:
控制器-->模型:调用
note right of 模型:完成数据库操作
模型-->控制器:返回数据
控制器-->视图:加载
note right of 视图:完成数据渲染
视图-->控制器:返回渲染数据
控制器-->入口文件\nindex.php:返回MVC处理结果
入口文件\nindex.php->服务器:PHP处理结果交给服务器
服务器->浏览器:服务器返回执行结果
note left of 浏览器:浏览器\n完成解析
```

2. 在真实项目单一入口中，入口文件通常会很简单，为了入口的可操作性，会将不同的内容分散到不同的文件中。一个简单的项目单一入口文件，也会将入口文件中的初始化部分，分离到另外一个文件中（初始化类）

* 入口文件index.php：加载初始化类，激活初始化类
* 初始化类：实现各类初始化（路径常量、系统设置、配置文件加载、路由功能、自动加载、控制器分发）



> **总结**

1. 单一入口是基于MVC思想的直接实现，用户的请求就是根据业务不同请求不同控制器

2. 项目单一入口是指用户所有的请求都是请求一个PHP入口文件，其他的事情都是PHP内部处理
3. 项目单一入口能够很好的保护系统内部的文件结构安全
4. 项目单一入口会增加前期开发难度，但是在开发后期就会轻松（基础部分只需要开发一次）