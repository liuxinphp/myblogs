# **博客项目开发**



## **一、 项目指导**

> **引入**：博客项目是指在前端人员已经设计好静态页面之后，通过PHP后台进行动态化实现。我们将依托自定义MVC框架来实现一个比较完整的博客项目。



1. 要实现的功能

* 后台功能
  * 权限功能
    * 登录验证
      * 用户数据表设计
      * 用户名验证用户的有效性
      * 密码有效性
      * session存储用户信息
    * 验证码功能
      * 生成验证码图片
      * 验证验证码有效性
    * 7天免登录
      * cookie存储信息
      * cookie验证登录
    * 退出登录
  * 首页功能
    * 头部信息展示
      * 用户信息展示
      * 头部链接
    * 左侧菜单管理
      * 菜单链接
      * 菜单权限
    * 控制面板信息
      * 客户端信息展示
      * 用户统计
  * 无限极分类功能
    * 无限极分类列表
      * 分类数据表设计
      * 无限极分类实现
    * 新增分类
    * 修改分类
    * 删除分类
  * 博文管理功能
    * 博文列表功能
      * 博文数据表设计
    * 博文检索
      * 检索功能实现
    * 分页功能
      * 京东分页功能
    * 新增博文
    * 文件上传
      * 单文件上传
    * 修改博文
    * 删除博文
  * 用户管理功能
    * 用户列表功能
      * 用户数据表设计
    * 新增用户
    * 删除用户
  * 评论管理功能
    * 评论给列表功能
      * 评论数据表设计
    * 删除评论
* 前台功能
  * 博文列表功能
    * 列表数据
    * 分页功能
    * 检索功能
  * 博文明细功能
    * 显示博文
  * 权限功能
    * 注册用户
    * 用户登录
  * 评论功能
    * 新增评论

2. 要用到的技术

* 面向对象思想
  * 封装
  * 继承

* 自定义MVC框架
  * MVC设计思想
  * 项目单一入口
* gd库图片制作
  * 验证码制作
  * 缩略图制作
* 文件上传技术
* 模板技术
  * smarty模板技术
* 分页技术
* 会话技术
  * session技术
  * cookie技术

3. 开发流程：基于功能实现的步骤完成

* 先完成后台独立功能：后台数据提供前台支持
* 后完成前台独立功能





##  **二、 项目前期准备**



### **1. 静态页准备**

> **引入**：静态页属于前端开发人员准备，但是前端的准备并不会也不能完全满足后台的实现便捷性，因此需要检验前端设计，在不需要前端开发人员调整的基础上，对前端设计的功能进行相关调整。



1. 获取博客项目静态资源，包括静态页、静态资源（HTML、CSS、JS和图片资源）

* 后台资源

![博客项目后台资源](效果图\博客项目后台资源.png)

* 前台资源

![博客项目前台资源](效果图\博客项目前台资源.png)



2. 资源检查：在众多页面中，是否有相同内容，可以独立维护：如果有，是否可以抽离出来独立维护

* 后台所有界面都有一个共同的头部

```html
<!-- START HEADER -->
    <div id="header">
        <!-- logo -->
        <div class="logo">	<a href="?"><span class="logo-text text-center font18">博客后台</span></a>	</div>

        <!-- notifications -->
        <div id="notifications">
            <div class="clear"></div>
        </div>

        <!-- quick menu -->
        <div id="quickmenu">
            <a href="#" class="qbutton-left tips" title="新增一篇博客"><img src="img/icons/header/newpost.png" width="18" height="14" alt="new post" /></a>
            <a href="#" class="qbutton-right tips" title="直达前台"><img src="img/icons/sidemenu/magnify.png" width="18" height="14" alt="new post" /></a>
            <div class="clear"></div>
        </div>

        <!-- profile box -->
        <div id="profilebox">
            <a href="#" class="display">
                <img src="img/simple-profile-img.jpg" width="33" height="33" alt="profile"/> <span>管理员</span> <b>昵称</b>
            </a>

            <div class="profilemenu">
                <ul>
                    <li><a href="#">退出</a></li>
                </ul>
            </div>
        </div>
        <div class="clear"></div>
    </div>
    <!-- END HEADER -->
```

* 后台所有界面都有一个共同的左边菜单部分

```html
<!-- START SIDEBAR -->
        <div id="sidebar">
            <div id="searchbox" style="z-index: 880;">
                <div class="in" style="z-index: 870;">
                    <p class="text-center font18 line-height35">此广告位常年招商</p>
                </div>
            </div>
            <!-- start sidemenu -->
            <div id="sidemenu">
                <ul>
                    <li class="active"><a href="index.html"><img src="img/icons/sidemenu/laptop.png" width="16" height="16" alt="icon"/>控制面板</a></li>
                    <!-- 分类管理 -->
                    <li class="subtitle">
                        <a class="action tips-right" href="#" title="分类管理"><img src="img/icons/sidemenu/key.png" width="16" height="16" alt="icon"/>分类管理<img src="img/arrow-down.png" width="7" height="4" alt="arrow" class="arrow" /></a>
                        <ul class="submenu display-block">
                            <li><a href="categoryIndex.html"><img src="img/icons/sidemenu/file.png" width="16" height="16" alt="icon"/>分类列表</a></li>
                            <li><a href="categoryAdd.html"><img src="img/icons/sidemenu/file_add.png" width="16" height="16" alt="icon"/>添加分类</a></li>
                        </ul>
                    </li>
                    <!-- 分类管理 -->

                    <!-- 博文管理 -->
                    <li class="subtitle">
                        <a class="action tips-right" href="#" title="博文管理"><img src="img/icons/sidemenu/mail.png" width="16" height="16" alt="icon"/>博文管理<img src="img/arrow-down.png" width="7" height="4" alt="arrow" class="arrow" /></a>
                        <ul class="submenu display-block">
                            <li><a href="articleAdd.html"><img src="img/icons/sidemenu/file_add.png" width="16" height="16" alt="icon"/>添加博文</a></li>
                            <li><a href="articleIndex.html"><img src="img/icons/sidemenu/file.png" width="16" height="16" alt="icon"/>博文列表</a></li>
                        </ul>
                    </li>
                    <!-- 博文管理 -->

                    <!-- 用户管理 -->
                    <li class="subtitle">
                        <a class="action tips-right" href="#" title="用户管理"><img src="img/icons/sidemenu/user.png" width="16" height="16" alt="icon"/>用户管理<img src="img/arrow-down.png" width="7" height="4" alt="arrow" class="arrow" /></a>
                        <ul class="submenu display-block">
                            <li><a href="userAdd.html"><img src="img/icons/sidemenu/user_add.png" width="16" height="16" alt="icon"/>添加用户</a></li>
                            <li><a href="userIndex.html"><img src="img/icons/sidemenu/file.png" width="16" height="16" alt="icon"/>用户列表</a></li>
                        </ul>
                    </li>
                    <!-- 用户管理 -->

                    <!-- 评论管理 -->
                    <li><a href="commentIndex.html"><img src="img/icons/sidemenu/file.png" width="16" height="16" alt="icon"/>评论列表</a></li>
                    <!-- 评论管理 -->
                </ul>
            </div>
            <!-- end sidemenu -->
        </div>
        <!-- END SIDEBAR -->
```

* 共同部分有内容是需要动态实现的或者每个界面都是共同结果，因此可以实现分离到两个独立的文件进行统一维护
  * header.html：将header部分的内容归集到一个文件
  * sidebar.html：将sidebar（目录）部分的内容归集到一个文件
* 后续所有界面中可以利用smarty的模板包含，将内容替换成对应的独立文件

```html
{include file='路径/header.html'}
{include file='路径/sidebar.html'}
```





### **2. 服务器准备**

> **引入**：任何PHP项目都要基于服务器才能对外提供服务，在开发阶段，我们可以在本地搭建一个模拟后期生产环境的服务器，来帮助开发。



1. 搭建开发目录：在D盘下，创建一个blog的文件夹，将之前的MVC自定义框架结构存放到该目录下

![博客项目开发目录](效果图\博客项目开发目录.png)

2. 在public目录下创建对应的home和admin文件夹，然后将博客项目对应的静态资源放入对应的目录下（js、css和image）

![博客项目开发目录](效果图\博客项目静态资源.png)

3. 增加Apache虚拟主机，指向D:/blog/public目录

```PHP
#配置博客项目的虚拟主机
<VirtualHost *:80>
    #指定文档位置：网站根目录
    DocumentRoot "D:/blog/public"
    #确定主机名
    ServerName www.blog.com

    #权限管理
    <Directory "D:/blog/public">
        #允许所有人访问
        Require all granted

        #配置默认访问页面：首先默认index.php
        DirectoryIndex index.php
    </Directory>
</VirtualHost>
```

4. 修改本地DNS系统hosts文件：增加www.blog.com的解析

```tex
127.0.0.1	www.blog.com
```

5. 测试访问到自定义MVC框架



## **三、 项目后台实现**



### **1. 后台权限功能实现【登录】**



#### **1.1 用户数据表设计**

> **引入**：所有功能的实现本质都是基于数据的处理，数据表的设计应该遵循数据库设计范式，数据字段依据功能需求来设定，必要时要设计部分字段冗余。



1. 创建数据库：数据库名字就是BLOG博客

```mysql
create database BLOG charset utf8;
```

2. 所有数据表都有表前缀：b_，所有表字段（逻辑主键除外）增加表前缀
3. 用户表应该包含字段信息如下

* id：主键自增长
* u_username：用户名，变长10个字符varchar(10)，不可重复
* u_password：密码，使用md5加密，定长32个字符char(10)
* u_reg_time：注册时间，时间戳，int unsigned
* u_is_admin：是否是管理员，迷你整型tinyint，0表示普通用户，1表示管理员

4. 创建用户表，并增加管理员用户信息

```mysql
create table if not exists b_user(
    id int primary key auto_increment,
    u_username varchar(10) not null unique,
    u_password char(32) not null,
    u_reg_time int unsigned not null,
    u_is_admin tinyint not null default 0 comment '0代表普通用户，1代表管理员'
)charset utf8;

insert into b_user values(null,'admin',md5('admin'),unix_timestamp(),1);
```





#### **1.2  实现登录功能**【加载登录表单】



1. 通过浏览器访问后台登录入口：http://www.blog.com/index.php?p=admin&c=privilege（默认a=index）
2. 系统提示没有PrivilegeController控制器：创建后台权限控制器app\admin\controller\PrivilegeController.php

```php
namespace admin\controller;
use \core\Controller.php;

class PrivilegeController extends Controller{
    
}
```

3. 再次浏览器进行访问，提示没有index方法：创建index方法，加载登录表单界面login.html

```PHP
public function index(){
    
    $this->display('login.html');
}
```

4. 再次访问：smarty提示加载不到login.html，因为在公共控制器Controller.php中smarty设置的模板路径是在view目录下要有对应的控制器文件夹`$this->smarty->template_dir = APP_PATH . P . '/view/' . C . '/';`，所以要在后台view目录下，创建对应的控制器文件夹Privilege，并且将login.html放入到该目录下

![博客项目视图管理](效果图\博客项目视图管理.png)

5. 再次访问：浏览器能够显示登录表单信息，但是整个样式内容都有问题，需要调整静态资源路径：利用smarty和自定义框架中设定的目录常量等，完成js、css和image的路径替换

```html
<link rel="stylesheet" type="text/css" href="{P}/css/app.css" />
<script type="text/javascript" src="{P}/js/app.js"></script>
```

6. 浏览器正常显示了登录表单信息

![博客项目登录表单效果](效果图\博客项目登录表单效果.png)



#### **1.3 实现登录功能【完成登录验证】**



1. 输入用户信息之后点击“登录”按钮无效：因为表单没有确定提交对象，所以需要修改login.html的表单form的action，明确提交对象

```html
<form id="form1" name="form1" method="post" action="index.php?p=admin&c=privilege&a=check">
    <label class="log-lab">用户名</label>
    <input name="u_username" type="text" class="login-input-user" id="textfield" value=""/>
    <label class="log-lab">密码</label>
    <input name="u_password" type="password" class="login-input-pass" id="textfield" value=""/>
</form>
```

2. 刷新浏览器再次点击登录，系统提示没有check方法：在PrivilegeController.php中增加check方法

```PHP
public function check(){
    //验证用户信息
}
```

3. 完成用户信息的验证

   3.1接收用户信息：用户名、密码和验证码（验证码暂时先不进行验证）

```PHP
$username = $_POST['u_username'] ?? '';
$password = $_POST['u_password'] ?? '';
$captcha  = $_POST['captcha']  ?? '';
```

​	3.2 PHP不应该相信任何外来数据，因此需要进行业务验证（合法性验证）

```PHP
#用户名和密码不能为空（验证码也不能为空）
if(empty(trim($username)) || empty(trim($password))){
    //调用公共控制器跳转提示方法：进入到index方法（即重新进入登录表单界面）
    $this->error('用户名和密码都不能为空！','index');
}
```

​	3.3 验证用户信息是否存在：应该调用\admin\model\UserModel()来验证数据

```PHP
//调用模型获取数据，并将获得的用户信息保存到$user表中
$user = new \admin\model\UserModel();
$user = $user->getUserByUsername($username);
```

​	3.4 系统会提示模型不存在：所以需要在app/admin/model/下创建UserModel.php文件，并且要实现通getUserByUsername方法

```PHP
namespace admin\model;
use \core\Model;

class UserModel extends Model{
    //属性：保存表名
    protected $table = 'user';
    
    //通过用户名获取用户信息
    public function getUserByUsername($username){
        //安全处理：为特殊字符增加斜杠
        $username = addslashes($username);
        //组织SQL
        $sql = "select * from {$this->getTable()} where u_username = '{$username}'";
        //执行：继承自父类Model::query方法，封装了Dao的query方法
        return $this->query($sql);
    }
}
```

​	3.5 此时若执行，就会提示表不存在，因为配置文件中定义的表前缀不对，因此需要修改对应的配置文件表前缀为b_

```PHP
return array(

	'database' => array(
		'type' => 'mysql',
		'host' => 'localhost',
		'user' => 'root',
		'pass' => 'root',
		'dbname' => 'BLOG',
		'charset' => 'utf8',
		'prefix' => 'b_'
	),
);
```

​	3.6 模型完成了需求，回到控制器PrivilegeController，我们需要判定用户是否存在

```PHP
#判定用户是否存在：拿到的就是一个数组，拿不到false。如果没有用户就提示用户信息不存在，并重新登录
if(!$user){
	$this->error('当前用户：' . $username . '不存在！','index' );
}
```

​	3.7 验证了用户信息存在后，我们接着验证用户的密码是否正确

```PHP
//密码验证：对用户密码进行md5加密后验证
if($user['u_password'] != md5($password)){
	$this->error('密码错误！','index');
}
```

​	3.8 用户信息验证成功：考虑到后续都需要确保用户登录成功了才能访问，需要将用户信息存入到session中

```PHP
//登录成功，开启session，将用户信息存入到session中
@session_start();				//可能其他地方已经开启，因此增加注释
$_SESSION['user'] = $user;
```

​	3.9 登录验证完成：提示用户登录成功，进入到首页

```PHP
#登录成功后提示跳转：进入到IndexController::index方法
$this->success('登录成功！欢迎来到博客系统后台！','index','index');
```





### **2. 后台首页实现**



#### **2.1 实现首页正常显示**



1. 增加后台首页控制器：app/admin/controller/IndexController.php

```PHP
namespace admin\controller;
use \core\Controller;

class IndexController extends Controller{
    
}
```

2. 增加index方法，显示模板

```PHP
//首页
public function index(){
    
    //利用Smarty加载模板
    $this->display('index.html');
}
```

3. 将模板添加到视图view下对应控制器文件件Index下

![博客项目视图管理-后台首页](效果图\博客项目视图管理-后台首页.png)

4. 模板中存在头部信息和侧边菜单部分存在重复，已经被抽离出来形成了header.html和sidebar.html，那么应该在view视图下创建一个Public目录，专门存放公共模板

![博客项目视图管理-后台首页](效果图\博客项目视图管理-公共模板.png)

5. 修改模板中对应的静态资源路径，使用Smarty包含标签，替换掉公共内容部分

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>博客后台</title>
    <link rel="stylesheet" type="text/css" href="{P}/css/app.css" />
    <script type="text/javascript" src="{P}/js/app.js"></script>
</head>
<body>
<div class="wrapper">
	<!-- START HEADER -->
    {include file="../Public/header.html"}
    <!-- END HEADER -->
    
    <!-- START MAIN -->
    <div id="main">
        <!-- START SIDEBAR -->
        {include file='../Public/sidebar.html'}
        <!-- END SIDEBAR -->

        <!-- START PAGE -->
        <div id="page">
            <!-- start page title -->
            <div class="page-title">
                <div class="in">
                    <div class="titlebar">
                        <h2>控制面板</h2>
                        <p>小标题</p>
                    </div>
                    <div class="clear"></div>
                </div>
            </div>
            <!-- end page title -->
            <!-- START CONTENT -->
            <div class="content">
                <!-- start simple tips -->
                <div class="simple-tips">
                    <h2>提示</h2>
                    <ul>
                        <li>1. 使用左侧的导航菜单进入功能</li>
                        <li>2. 使用右上角的退出按钮退出管理后台</li>
                    </ul>
                    <a href="#" class="close tips" title="关闭">关闭</a>
                </div>
                <div class="simple-tips">
                    <h2>提示</h2>
                    <ul>
                        <li>1. 您当前使用的ip: </li>
                        <li>2. PHP版本: </li>
                        <li>3. 浏览器: </li>
                    </ul>
                    <a href="#" class="close tips" title="关闭">关闭</a>
                </div>

                <!-- start dashbutton -->
                <div class="grid740">
                    <span class="dashbutton">	<img src="{P}/img/icons/dashbutton/users.png" width="44" height="32" alt="icon" />	<b>用户数</b>	</span>
                    <div class="clear"></div>
                </div>

                <div class="clear"></div>
            </div>
            <!-- END CONTENT -->
        </div>
        <!-- END PAGE -->
    <div class="clear"></div>
    </div>
    <!-- END MAIN -->

    <!-- START FOOTER -->
    <div id="footer">
    	<div class="left-column">© Copyright 2020 - 保留所有权利.</div>
    </div>
    <!-- END FOOTER -->
</div>
</body>
</html>
```



#### **2.2 显示首页数据**



1. 首页界面数据显示：IP地址、PHP版本和浏览器信息：这些可以通过$_SERVER和PHP_VERSION常量获取，在模板中利用smarty展示出来

```html
<ul>
    <li>1. 您当前使用的ip: {$smarty.server.REMOTE_ADDR}</li>
    <li>2. PHP版本: {PHP_VERSION}</li>
    <li>3. 浏览器: {$smarty.server.HTTP_USER_AGENT}</li>
</ul>
```

2. 显示登录的用户信息：从PrivilegeController::check()到IndexController::index()，实际已经是从浏览器发起了两次请求，也就是跨脚本。跨脚本共享数据就要用到会话技术，后台核心用户信息应该保存到session中（安全），需要现在控制器中开启session，然后在模板中使用smarty访问session数据，模板为公共模板header.html

```PHP
#IndexController::index()
public function index(){
    
    #开启session
    @session_start();
    //利用Smarty加载模板
    $this->display('index.html');
}
```

```html
<!--header.html-->
<div id="header">
   <!-- logo -->
   <div class="logo">	<a href="{URL}?p=admin"><span class="logo-text text-center font18">博客后台</span></a>	</div>

      <!-- notifications -->
      <div id="notifications">
        <div class="clear"></div>
      </div>

      <!-- quick menu -->
      <div id="quickmenu">
          <a href="#" class="qbutton-left tips" title="新增一篇博客"><img src="{P}/img/icons/header/newpost.png" width="18" height="14" alt="new post" /></a>
          <a href="index.php" class="qbutton-right tips" title="直达前台"><img src="{P}/img/icons/sidemenu/magnify.png" width="18" height="14" alt="new post" /></a>
          <div class="clear"></div>
      </div>

      <!-- profile box -->
      <div id="profilebox">
       <a href="#" class="display">
           <img src="{P}/img/simple-profile-img.jpg" width="33" height="33" alt="profile"/> <span>{if $smarty.session.user.u_is_admin}管理员{else}用户{/if} </span> <b>昵称：{$smarty.session.user.u_username}</b>
       </a>

       <div class="profilemenu">
        <ul>
            <li><a href="">退出</a></li>
           </ul>
       </div>
   </div>
   <div class="clear"></div>
</div>
```

3. 显示用户数量：在IndexController控制器中通过调用用户模型UserModel获取所有的用户信息（数量），并且分配给模板

```PHP
#IndexController::index()
public function index(){
    #获取用户数量
    $user = new \admin\model\UserModel();
    $counts = $user->getCounts();
    
    #开启session
    @session_start();
    
    //分配数据给模板
    $this->assign('counts',$counts);
    //利用Smarty加载模板
    $this->display('index.html');
}
```

```PHP
#UserModel::getCounts()
public function getCounts(){
    //组织SQL
    $sql = "select count(*) as c from {$this->getTable()}";
    //执行并解析数据返回
    $res = $this->query($sql);
    return $res['c'] ?? 0;		//如果没有数据就返回0
}
```

```html
<!--index.html-->
<!-- start dashbutton -->
<div class="grid740">
    <span class="dashbutton">	<img src="{P}/img/icons/dashbutton/users.png" width="44" height="32" alt="icon" />	<b>用户数</b>{$counts}</span>
    <div class="clear"></div>
</div>
```



#### **2.3 根据权限控制菜单功能**



1. 后台根据不同的用户类型应该有不同的权限：管理员拥有全部权限，普通用户只能看到进行博文增删改查。因此需要在sidebar.html中进行条件筛查

```html
<div id="sidebar">
    <div id="searchbox" style="z-index: 880;">
        <div class="in" style="z-index: 870;">
            <p class="text-center font18 line-height35">此广告位常年招商</p>
        </div>
    </div>
    <!-- start sidemenu -->
    <div id="sidemenu">
     <ul>
         <li class="active"><a href="index.php?p=admin"><img src="{P}/img/icons/sidemenu/laptop.png" width="16" height="16" alt="icon"/>控制面板</a></li>
            {if $smarty.session.user.u_is_admin}
            <!-- 分类管理 -->
            <li class="subtitle">
                <a class="action tips-right" href="#" title="分类管理"><img src="{P}/img/icons/sidemenu/key.png" width="16" height="16" alt="icon"/>分类管理<img src="{P}/img/arrow-down.png" width="7" height="4" alt="arrow" class="arrow" /></a>
                <ul class="submenu display-block">
                    <li><a href=""><img src="{P}/img/icons/sidemenu/file.png" width="16" height="16" alt="icon"/>分类列表</a></li>
                            
                    <li><a href=""><img src="{P}/img/icons/sidemenu/file_add.png" width="16" height="16" alt="icon"/>添加分类</a></li>
                            
                </ul>
            </li>
            <!-- 分类管理 -->
            {/if}

            <!-- 博文管理 -->
            <li class="subtitle">
             <a class="action tips-right" href="#" title="博文管理"><img src="{P}/img/icons/sidemenu/mail.png" width="16" height="16" alt="icon"/>博文管理<img src="{P}/img/arrow-down.png" width="7" height="4" alt="arrow" class="arrow" /></a>
             <ul class="submenu display-block">
                <li><a href=""><img src="{P}/img/icons/sidemenu/file_add.png" width="16" height="16" alt="icon"/>添加博文</a></li>
                <li><a href=""><img src="{P}/img/icons/sidemenu/file.png" width="16" height="16" alt="icon"/>博文列表</a></li>
                </ul>
            </li>
            <!-- 博文管理 -->
            {if $smarty.session.user.u_is_admin}
            <!-- 用户管理 -->
            <li class="subtitle">
                <a class="action tips-right" href="#" title="用户管理"><img src="{P}/img/icons/sidemenu/user.png" width="16" height="16" alt="icon"/>用户管理<img src="{P}/img/arrow-down.png" width="7" height="4" alt="arrow" class="arrow" /></a>
                <ul class="submenu display-block">
                    <li><a href=""><img src="{P}/img/icons/sidemenu/user_add.png" width="16" height="16" alt="icon"/>添加用户</a></li>
                    <li><a href=""><img src="{P}/img/icons/sidemenu/file.png" width="16" height="16" alt="icon"/>用户列表</a></li>
                </ul>
            </li>
            <!-- 用户管理 -->
                    
            <!-- 评论管理 -->
            <li><a href=""><img src="{P}/img/icons/sidemenu/file.png" width="16" height="16" alt="icon"/>评论列表</a></li>
            <!-- 评论管理 -->
            {/if}
        </ul>
    </div>
    <!-- end sidemenu -->
</div>
```



### **3. 公共安全管理**



#### **3.1 后台访问权限管理**

> **引入**：所有后台业务除了用户在登录时访问的两个功能：PrivilegeController::index和PrivilegeController::check之外，其他的功能访问都是需要验证用户是否登录的，所以每个控制器的几乎每个方法都需要先进行用户权限验证，为了实现代码的共用，应当提升到父类控制器中，而当前我们的设计只有一层父类（前后台共用），在不改变当前架构的前提下，需要对平台进行限定（前台不用全部限定权限）



1. 找到公共控制器，并且在一开始就进行权限验证，所以应该在公共控制器的构造方法中进行权限验证

```PHP
#Controller.php中的Controller::__construct()
public function __construct(){
    //引入smarty：假设在vendor/smarty/Smarty.class.php中
	include VENDOR_PATH . 'smarty/Smarty.class.php';
	$this->smarty = new \Smarty();
	//设置Smarty
	$this->smarty->template_dir = APP_PATH . P . '/view/' . C . '/';	    
	$this->smarty->caching = false;				//开发阶段不缓存
	$this->smarty->cache_dir = ROOT_PATH . 'cache';
	$this->smarty->cache_lifetime = 120;
	$this->smarty->compile_dir = ROOT_PATH . 'template_c';

	//后台开启session，并判定用户是否需要验证身份
	if(P == 'admin'){
         @session_start();

         //判定是否有权限：当前只判定是否属于权限模块（index\check\captcha）
         if(!isset($_SESSION['user']) && strtolower(C) !== 'privilege'){
             //先登录
             $this->error('请先登录','index','privilege');
         }
    }
}
```

2. 在公共控制器开启session后，后台的所有位置都不再需要开启session而直接使用session了，同时也不需要额外书写验证用户是否登录的代码了

`http://www.blog.com/index.php?p=admin`开启访问系统会自动判定是否有权限访问（默认访问IndexController::index）



### **4. 后台权限功能实现**



#### **4.1 7天免登录**

> **引入**：所谓7天免登录，即用户在登录的时候选择了记住用户信息，后台会自动设置7天的有效时间，然后用户在7天内，在非正常退出情况下访问后台都不需要登录（后台帮助其登录）。免登录是利用cookie保存数据到浏览器端，并借助该cookie来实现。



1. 在用户登录验证的时候，判定用户是否选择了免登录，如果有，在用户登录成功后，将用户的id信息存储到浏览器上：保存时间7天

```php
#PrivilegeController::login()

//7天免登录：登录成功后
if(isset($_POST['rememberMe'])){
    //7天免登录
    setcookie('user_id',$user['id'],time() + 7 * 24 * 3600);
}
```

2. 用户在访问后台非登录表单界面时（默认IndexController::index()），除了判定session还要进行cookie判定

```PHP
#Controller::__construct()

//判定用户是否7天免登录：在session判定之后
//判定是否有权限
if(!isset($_SESSION['user']) && strtolower(C) !== 'privilege'){
	//现在不能直接判定，还需要判定session
    if(isset($_COOKIE['user_id'])){
        //可能免登录了（不确定是否有效）
        $u = new \admin\model\UserModel();
        $user = $u->getById((int)$_COOKIE['user_id']);
        
        //判定用户是否有效
        if($user){
            //能够登录：帮助登录
            $_SESSION['user'] = $user;
            //重新访问用户访问的链接
            $this->success('欢迎访问博客系统！',A,C,P);
        }
    }
    
    //没有session也没有cookie，或者cookie无效
	$this->error('请先登录','index','privilege');	
}
```





#### **4.2 退出系统**

> **引入**：所谓退出，即当前用户访问不再能访问后台功能，而限制用户是否能访问后台的前提是用户是否登录，体现在具体技术实现上就是通过session进行验证。因此要实现退出，就是将当前用户的session信息给去除（销毁session文件），如果用户选择了7天免登录，还要清除相应的cookie信息。

1. 找到退出功能用户操作入口，增加相应的操作路径：在header.html中

```html
<!-- profile box -->
<div id="profilebox">
 <a href="#" class="display">
     <img src="{P}/img/simple-profile-img.jpg" width="33" height="33" alt="profile"/> <span>{if $smarty.session.user.u_is_admin}管理员{else}用户{/if} </span> <b>昵称：{$smarty.session.user.u_username}</b>
    </a>

    <div class="profilemenu">
     <ul>
         <li><a href="{URL}index.php?p=admin&c=privilege&a=logout">退出</a></li>
        </ul>
    </div>
</div>
<div class="clear"></div>
```

2. 在权限控制器中增加相应处理方法：PrivilegeController::logout，实现session的删除操作，以及可能存在的cookie数据

```PHP
#PrivilegeController::logout
#退出系统
public function logout(){
    //清除cookie数据
    setcookie('user_id','',1);		//1秒过期
    
    //删除session文件
    session_destroy();

    //提示并进入到前台首页
	$this->success('退出成功！欢迎下次进入博客后台！','index','index','home');
}
```





### **5. 验证码功能**

> **引入**：验证码的存在是为了防止不良对手恶意访问服务器，占用服务器资源，而让正常用户无法访问。验证码是利用GD库将随机字符串放到图片上，从而干扰计算机识别；验证码验证是利用session在服务端存储生成的验证码，然后实现用户提交后对比校验。



#### **5.1 生成验证码图片**



1. 验证码可以作为一类插件（偶尔被使用），因此可以在vendor目录下存放

```PHP
#Captcha.php：负责生成验证码以及验证码的验证等
namespace vendor;

class Captcha{
    
}
```

2. 验证码的制作就是一个方法，为了减少内存的消耗，不产生不必要的对象，可以将生成验证码的工作用静态方法实现

```PHP
#生成验证码
public static function getCaptcha(){}
```

3. 验证码的生成应该是灵活的，因此需要外部提供一些参数来实现灵活性。图片的宽、高、验证码长度以及对应的字体（imagestring写的字体太小，使用imagettftext）

```PHP
#生成验证码
/*
 * @param1 int $width = 450，验证码图片默认宽度
 * @param2 int $height = 65，验证码图片默认高度
 * @param3 int $length = 4，验证码默认字符数
 * @param4 string $fonts = ''，验证码字体，默认为空（内部使用默认字体）
*/
public static function getCaptcha($width = 450,$height = 65,$length = 4,$fonts = ''){}
```

4. 考虑到要使用到默认字体，应该把对应的字体存放到vendor目录下的新建文件夹fonts下：如果用户想要使用别的字体，那么需要先把字体放到当前fonts文件夹下

![博客项目验证码字体目录](效果图\博客项目验证码字体目录.png)

5. 验证码的生成需要用到字体资源，可以先确定字体资源（取出名字）

```PHP
#判定用户是否有提供字体：只需要字体名字
if(empty($fonts)) $fonts = 'seguihis.ttf';

//构造字体文件目录（正常应该还要判定下文件是否存在）
$fonts = __DIR__ . 'fonts/' . $fonts;
```

6. 当字体资源确定后，就可以生成图片并填充背景了：采用浅色随机背景

```PHP
//生成图片资源
$img = imagecreatetruecolor($width, $height);

//填充背景色：随机
$bg_color=imagecolorallocate($img,mt_rand(200,255),mt_rand(200,255),mt_rand(200,255));
imagefill($img, 0, 0, $bg_color);
```

7. 完成背景色之后增加干扰点：随机颜色，比背景色稍深

```PHP
//增加干扰点
for($i = 0;$i < 50;$i++){
	//随机颜色
	$dots_color = imagecolorallocate($img, mt_rand(140,190), mt_rand(140,190), mt_rand(140,190));
    //使用*号作为干扰点
	imagestring($img, mt_rand(1,5), mt_rand(0,$width), mt_rand(0,$height), '*', $dots_color);
}
```

8. 增加干扰线：随机颜色，比干扰点颜色稍深

```PHP
//增加干扰线
for($j = 0;$j < 10;$j++){
	$line_color = imagecolorallocate($img, mt_rand(80,130), mt_rand(80,130), mt_rand(80,130));
    //随机线段
	imageline($img, mt_rand(0,$width), mt_rand(0,$height), mt_rand(0,$width), mt_rand(0,$height), $line_color);
}
```

9. 完成了干扰部分，接下来要实现随机字符写入图片，此时可以将生成随机字符串这块重新增加一个方法

```PHP
//生成随机字符串：利用chr()将数字转换成ASCII字符
private static function getString($length = 4){
	//从ASCII码中获取
	$captcha = '';

	//随机取：大写、小写、数字
	for($i = 0;$i < $length; $i++){
        //随机确定是字母还是数字
		switch(mt_rand(1,3)){
			case 1:				//数字：49-57分别代表1-9
				$captcha .= chr(mt_rand(49,57));	
				break;
			case 2:				//小写字母
				$captcha .= chr(mt_rand(65,90));
				break;
			case 3:				//大写字母
				$captcha .= chr(mt_rand(97,122));
				break;
		}
	}
		
	//返回
	return $captcha;	
}
```

10. 在验证码制作方法中调用获取随机字符串方法，并且存入到session中

```PHP
//调用获得随机字符串
$captcha = self::getString($length);

//确保session开启，然后保存
@session_start();	
$_SESSION['captcha'] = $captcha;
```

11. 将得到的随机字符串写入到图片中：让不同的字符有不同的大小和效果

```PHP
for($i = 0;$i < $length;$i++){
    //给每个字符分配不同颜色
	$c_color = imagecolorallocate($img, mt_rand(0,60), mt_rand(0,60), mt_rand(0,60));
    //简单操作可以利用imagestring（字体太小，而且没有特效）
	// imagestring($img, mt_rand(4,5), $width/($length+1)*($i+1), mt_rand(10,$height-20), $captcha[$i], $c_color);
    
    //增加字体空间、大小、角度显示
	imagettftext($img, mt_rand(15,25), mt_rand(-45,45), $width/($length+1)*($i+1), mt_rand(25,$height-25), $c_color,$fonts, $captcha[$i]);
}

```

12. 输出图片并销毁资源

```PHP
//输出：错误调试时应该注释header
header('Content-type:image/png');
imagepng($img);

//销毁资源
imagedestroy($img);
```



#### **5.2 使用验证码图片**



1. 验证码是在登录时利用一个图片显示数据，应该在login.html登录表单中，增加一个img图标来显示验证码

```html
<label class="log-lab">验证码</label>
<div class="padding-bottom5"><img src=""></div>
<input name="captcha" type="text" class="login-input" id="textfield" value=""/>
```

2. 图片资源加载是浏览器发起，所有请求都应该请求单一入口，而验证码属于权限管理附属功能，因此应该找PrivilegeController::captcha方法来实现

````html
<label class="log-lab">验证码</label>
<div class="padding-bottom5"><img src="index.php?p=admin&c=privilege&a=captcha"></div>
<input name="captcha" type="text" class="login-input" id="textfield" value=""/>
````

3. 在PrivilegeController中增加captcha方法，并调用验证码类实现验证码图片

```PHP
#PrivilegeController::captcha

//获取验证码图片
public function captcha(){
    //调用插件类Captcha
    \vendor\Captcha::getCaptcha();
}
```

4. 用户在使用验证码图片的时候，可能因为某些角度或者字符不好识别时应该能够点击切换，此时需要用到浏览器检测到img的src改变会自动发起申请的特性：实现点击图片修改src（注意点击多次每次都要不一样，可以通过一个无用随机数来添加到URL后面）

```html
<label class="log-lab">验证码</label>
<div class="padding-bottom5"><img src="index.php?p=admin&c=privilege&a=captcha" onclick="this.src='index.php?p=admin&c=privilege&a=captcha&'+Math.random()"></div>
<input name="captcha" type="text" class="login-input" id="textfield" value=""/>
```



#### **5.3 验证验证码**



1. 在进行用户身份验证的时候已经接收了用户提交的验证码数据，此时需要先对验证码的合法性进行验证

```php
#PrivilegeController::check()

#在验证用户名和密码有效性验证之前验证验证码
if(empty($captcha)){
	$this->error('验证码不能为空！','index');
}
```

2. 在验证完所有信息的有效性之后（用户名和密码不为空），先进行验证码校验：既然是验证码的工作，应该交给验证码插件去完成（虽然代码很少）

```PHP
#PrivilegeController::check()

#在用户名和密码不为空之后验证
if(!\vendor\Captcha::checkCaptcha($captcha)){
	$this->error('验证码错误！','index');
}
```

3. 在验证码类中增加对应的验证方式

```PHP
#Captcha::checkCaptcha()

#校验验证码正确性
public static function checkCaptcha($captcha){
    //确保session开启（当前框架而言，后台部分做过统一开启，但是其他地方未必）
	@session_start();
    //不区分大小写比较
	return (strtolower($captcha) === strtolower($_SESSION['captcha']));
}
```



### **6. 分类管理功能**

> **引入**：分类使用的并非固定层级分类，而是使用无限极分类，即某个分类会有多层上级类也有可能有多层下级类，具体层级数不确定。



#### **6.1无限极分类数据表设计**



 	1. 分类表（b_category）包含字段如下

* id：自增长逻辑主键
* c_name：分类名字，varchar(10），同级分类下不应该有同名分类
* c_sort：排序，int unsigned 默认0
* c_parent_id：分类的上级分类ID，顶级分类ID值为0

2. 创建分类表，并增加部分测试数据

```mysql
create table if not exists b_category(
	id int primary key auto_increment,
    c_name varchar(10) not null,
    c_sort int unsigned default 0,
    c_parent_id int unsigned default 0,
    unique key(c_name,c_parent_id)
)charset utf8;

insert into b_category values(1,'IT技术',0,0),
(2,'电子商务',0,0),
(3,'影视',0,0),
(4,'PHP',0,1),
(5,'面向对象',0,4),
(6,'MVC思想',0,4);
```



#### **6.2 显示无限极分类**



1. 修改左侧菜单栏（sidebar.html）中的分类列表链接：指向分类的显示所有分类功能：CategoryController::index

```html
<!-- 分类管理 -->
<li class="subtitle">
    <a class="action tips-right" href="#" title="分类管理"><img src="{P}/img/icons/sidemenu/key.png" width="16" height="16" alt="icon"/>分类管理<img src="{P}/img/arrow-down.png" width="7" height="4" alt="arrow" class="arrow" /></a>
    <ul class="submenu display-block">
        <!--在a标签的href中增加点击链接，请求后台相应-->
        <li><a href="index.php?p=admin&c=category"><img src="{P}/img/icons/sidemenu/file.png" width="16" height="16" alt="icon"/>分类列表</a></li>
                            
        <li><a href="#"><img src="{P}/img/icons/sidemenu/file_add.png" width="16" height="16" alt="icon"/>添加分类</a></li>
                            
    </ul>
</li>
<!-- 分类管理 -->
```

2. 刷新首页点击菜单列表，系统提示没有CategoryController类：在app/admin/controller/下创建CategoryController::index()

```php
#CategoryController
namespace admin\controller;
use \core\Controller;

class CategoryController extends Controller{
    
    //显示无限极分类
    public functon index(){
      
        //显示模板
        $this->display('categoryIndex.html');
    }
}
```

3. 将无限极分类的相关静态页，存放到app/admin/view/下创建Category文件夹下

![博客项目视图管理-后台分类](效果图\博客项目视图管理-后台分类.png)

4. 控制器应该调用模型获取分类数据：已经排好序，且分类层级明确

```PHP
//获取所有无限极分类信息：已经进行无限极分类好
$c = new \admin\model\CategoryModel();
$categories = $c->getAllCategories();

//因为得到无限极分类会比较麻烦，后续又用的可能比较多，所以可以保存到session中来提升效率
$_SESSION['categories'] = $categories;
```

5. 创建无限极分类模型：并增加实现无限极分类数据获取的方法：app/admin/model/CategoryModel::index

```PHP
#CategoryModel
namespace admin\model;
use \Core\Model;

class CategoryModel extends Model{
    //属性保存表名
    protected $table = 'category';
    
    //获取所有分类信息
    public function getAllCategories(){
       //获取所有分类信息：根据排序降序排序（数值越大，排序越高）
    	$sql = "select * from {$this->getTable()} order by c_sort desc";
    	$categories = $this->query($sql,true); 
    }   
}
```

6. 模型通过查询所有获取到的分类数据并没有进行分层以及分类，而且没有明确谁是谁的子类，不适合显示数据。应该调整为如下

-- 顶级分类{id，c_name , c_sort , c_parent_id}

---- 子分类{id，c_name , c_sort , c_parent_id}

------ 孙子分类{id，c_name , c_sort , c_parent_id}

---- 子分类{id，c_name , c_sort , c_parent_id}

------ 孙子分类{id，c_name , c_sort , c_parent_id}

以上数据就适合遍历输出，但是光数据表字段不足以支撑层级，因此需要在数据中给每条记录增加一个level表示所属层级，0级表示顶级，1级表示上级子类，依次类推{id，c_name , c_sort , c_parent_id，level}。此加工工程量比较大，可以考虑单独建立一个无限极效果功能CategoryModel::noLimitCategory()

```PHP
/*
 * 无限极分类
 * @param1 array $categories，一个包含无限分类的数组
 * @param2 int $parent_id = 0，要确定从哪层开始寻找分类，默认为顶层，即找出所有分类
 * @param3 int $level = 0,当前得到的分类的有效层级，因为默认从顶级开始查，所以顶级的级别是0
 * @return array $list，分好类，同时每个分类添加了level元素的二维数组
*/
public function noLimitCategory($categories,$parent_id = 0,$level = 0){
    //因为寻找每次只能找一层：所以意味着找下层就要调用自己，应用递归，而跨方法保存数据需要使用静态变量
    static $list = array();
    
    //遍历数组：找出当前符合指定层次的分类
    foreach($categories as $cat){
        //当前分类的父分类id如果与要找的相同，当前分类就是目标分类
        if($cat['c_parent_id'] == $parent_id){
            //为当前分类添加上层级
            $cat['level'] = $level;
            //有效分类：保留在记录中，使用当前分类的ID作为数组的下标（方便以后其他应用）
            $list[$cat['id']] = $cat;
            
            //当前分类不一定是最终分类，可能还有子分类：应该找出所有的子分类，当前分类作为要找的分类的父分类，同时子分类对应的层级应该+1（递归点）
            noLimitCategory($categories,$cat['id'],$level+1);
        }
    }
    
    //返回所有数据：最外层找顶层分类都找完了，数组遍历结束（递归出口）
    return $list;
}
```

7. 在获取分类的CategoryModel::getAllCategories()获取到数据之后，应该调用无限极分类方法来实现无限极分类处理

```PHP
#CategoryModel::getAllCategories()

//获取所有分类信息
public function getAllCategories(){
   //获取所有分类信息：根据排序降序排序（数值越大，排序越高）
   $sql = "select * from {$this->getTable()} order by c_sort desc";
   $categories = $this->query($sql,true); 
    
    //进行无限极处理
    return $this->noLimitCateogry($categories);
}  
```

8. 在模板中显示所有数据：对表格的行进行foreach循环，子分类前使用`--`来表示是子分类，不同级别子分类增加不同数量

```html
{foreach $smarty.session.categories as $cat}
<tr>
    <td>{$cat.c_id}</td>
    <!--利用PHP函数str_repeat()来实现'--'的重复-->
    <td>{str_repeat('--',$cat['level'] * 2)}{$cat.c_name}</td>
    <td>2</td>
    <td>{$cat.c_sort}</td>
    <td>
        <a href="">编辑</a>
        <a href="">删除</a>
    </td>
</tr>
{/foreach}
```



#### **6.3 新增无限极分类【显示表单】**



1. 在左侧菜单列表中，增加新增分类的操作入口，即点击链接，执行CategoryController::add()方法

```html
<!-- 分类管理 -->
<li class="subtitle">
    <a class="action tips-right" href="#" title="分类管理"><img src="{P}/img/icons/sidemenu/key.png" width="16" height="16" alt="icon"/>分类管理<img src="{P}/img/arrow-down.png" width="7" height="4" alt="arrow" class="arrow" /></a>
    <ul class="submenu display-block">
        <li><a href="index.php?p=admin&c=category"><img src="{P}/img/icons/sidemenu/file.png" width="16" height="16" alt="icon"/>分类列表</a></li>
        <!--在a标签的href中增加点击链接，请求后台相应-->              
        <li><a href="index.php?p=admin&c=category&a=add"><img src="{P}/img/icons/sidemenu/file_add.png" width="16" height="16" alt="icon"/>添加分类</a></li>
                            
    </ul>
</li>
<!-- 分类管理 -->
```

2. 在控制器中增加相应方法实现categoryAdd.html模板的加载

```PHP
#CategoryController::add()

//新增分类表单
public function add(){
    
    //加载模板
    $this->display('categoryAdd.html');
}
```

3. 发现模板中在进行添加分类的时候，需要选择当前已有的分类作为父分类，那么需要显示所有的分类出来，而前面可能已经产生过分类（查看分类的时候保存到session中），所以可以在控制器先判定，如果不存在再调用模型获取

```PHP
#CategoryController::add()

//新增分类模板显示
public function add(){
    //判定分类是否已经有
    if(!isset($_SESSION['categories'])){
        //没有：重新获取
        $c = new \admin\model\CategoryModel();
		$categories = $c->getAllCategories();
        
        //同时保存到session
        $_SESSION['categories'] = $categories;
    }
    
	//加载模板
	$this->display('categoryAdd.html');
}
```

4. 在新增模板categoryAdd.html中显示所有的分类

```php+HTML
<select name="c_parent_id" class="uniform">
    <option value="0">无</option>
    {foreach $smarty.session.categories as $cat}
    <option value="{$cat.c_id}">{str_repeat('--',$cat['level'] * 2)}{$cat.c_name}</option>
    {/foreach}
</select>
```



#### **6.4 新增无限极分类【数据入库】**



1. 修改categoryAdd.html表单form的提交对象

```php+HTML
<form id="form2" name="form2" method="post" action="index.php?p=admin&c=category&a=insert">
</form>
```

2. 在分类控制器中增加对应的方法，CategoryController::insert()

```PHP
#CategoryController::insert()

//新增分类入库
public function insert(){
    
}
```

3. 数据接收

```PHP
#CategoryController::insert()
//接收数据
$c_name = trim($_POST['c_name']);
$c_parent_id = $_POST['c_parent_id'];
$c_sort = trim($_POST['c_sort']);
```

4. 合法性验证：分类名字不能为空，排序必须为正整数

```PHP
#CategoryController::insert()
//合法性验证
if(empty($c_name)){
	$this->error('分类名字不能为空！','add');
}

//排序必须为整数
if(!is_numeric($c_sort) || (int)$c_sort != $c_sort || $c_sort < 0 || $c_sort > PHP_INT_MAX){
	$this->error('排序必须为一个正整数！','add');
}
```

5. 合理性验证：当前父分类下不应该有同名的分类，应该调用模型验证当前指定的父分类下是否有同名分类

```PHP
#CategoryController::insert()

//有效性验证：确保不会在同一父类下出现同名分类
$c = new \admin\model\CategoryModel();
if($c->checkCategoryName((int)$c_parent_id),$c_name)){
    //查到数据：说明已经存在，重新来过
    $this->error('当前分类名字：' . $c_name . ' 在所选父分类下已经存在！','add');
}
```

6. 在模型中增加对应的验证方法：返回存在的分类的ID，CategoryModel::checkCategoryName()

```PHP
#CategoryModel::checkCategoryName()

//查询指定父分类下是否有同名分类，有返回同名分类数组（只有id），没有返回false
public function checkCategoryName(int $c_parent_id,string $c_name){
    //组织SQL
    $sql = "select id from {$this->getTable()} where c_parent_id = {$c_parent_id} and c_name = '{$c_name}'";
    //执行
    return $this->query($sql);
}
```

7. 如果没有同名分类，那么继续执行，可以将当前用户新增的分类插入到数据库，应该在控制器中调用相应的模型来进行数据库操作实现

```PHP
#CategoryController::insert()

//数据入库
if($c->insertCategory((int)$c_parent_id,$c_name,(int)$c_sort)){
    //插入成功
	$this->success('分类：' . $c_name . ' 新增成功！','index');
}else{
    //插入失败
    $this->error('分类：' . $c_name . ' 新增失败！','add');
}
```

8. 在模型中增加插入分类数据的方法，CategoryModel::insertCategory()

```PHP
#CategoryModel::insertCategory()

//新增分类数据入库
public function insertCategory(int $c_parent_id,string $c_name,int $c_sort){
    //组织SQL并执行
    $sql = "insert into {$this->getTable()} values(null,'{$c_name}',{$c_sort},{$c_parent_id})";
    return $this->exec($sql);
}
```



#### **6.5 删除无限极分类**



1. 在分类列表数据表右侧操作栏中，增加删除分类的操作入口，即点击链接，执行CategoryController::delete()方法（注意删除需要明确要删除谁：根据ID进行删除）

```html
<!--categoryIndex.html-->
{foreach $smarty.session.categories as $cat}
<tr>
    <td>{$cat.c_id}</td>
    <!--利用PHP函数str_repeat()来实现'--'的重复-->
    <td>{str_repeat('--',$cat['level'] * 2)}{$cat.c_name}</td>
    <td>2</td>
    <td>{$cat.c_sort}</td>
    <td>
        <a href="">编辑</a>
        <a href="index.php?p=admin&c=category&a=delete&id={$cat.id}">删除</a>
    </td>
</tr>
{/foreach}
```

2. 数据的删除操作是需要谨慎操作的，因此通常会增加一个js提示用户是否确认删除防止误操作：利用js的confirm函数

```html
<a href="index.php?p=admin&c=category&a=delete&id={$cat.id}" onClick="return confirm('确认删除：{$cat.c_name} 分类？')">删除</a>
```

3. 在控制器增加删除方法，CategoryController::delete()

```PHP
#CategoryController::delete()

//删除分类
public function delete(){
    
}
```

4. 接收要删除的分类ID数据，并确保数据合法

```PHP
#CategoryController::delete()

//接收数据验证合法性，强制转换成整型
$id = (int)$_GET['id'];
```

5. 验证分类是否可以删除：有子分类不能删除，有博文不能删除（暂时不做）

```PHP
#CategoryController::delete()

//验证是否可删除：是否有子分类
$c = new \admin\model\CategoryModel();
if($c->getSon($id)){
    //说明有子分类，不能删除
    $this->error('当前分类存在子分类，不能删除！','index');
}

//验证是否可删除：是否已经拥有博文（后续博文实现后完成）
```

6. 实现博文删除：控制器调用模型方法

```PHP
#CategoryController::delete()

//删除分类
if($c->deleteById($id)){
    $this->success('分类删除成功！','index');
}else{
    $this->error('分类删除失败！','index');
}
```

7. 增加模型处理方法：几乎所有数据都有根据主键删除的需求，所以在公共模型中处理

```PHP
#Model::deleteById()

//根据主键删除数据
public function deleteById($id){
	//判定：当前表是否有主键
	if(!isset($this->fields['Key'])) return false;

	//组织SQL执行删除操作
	$sql = "delete from {$this->getTable()} where {$this->fields['Key']} = '{$id}'";
	return $this->exec($sql);
}
```





#### **6.6 编辑无限极分类【显示分类】**



1. 在分类列表数据表右侧操作栏中，增加编辑分类的操作入口，即点击链接，执行CategoryController::edit()方法

```php+HTML
<!--categoryIndex.html-->
{foreach $smarty.session.categories as $cat}
<tr>
    <td>{$cat.c_id}</td>
    <!--利用PHP函数str_repeat()来实现'--'的重复-->
    <td>{str_repeat('--',$cat['level'] * 2)}{$cat.c_name}</td>
    <td>2</td>
    <td>{$cat.c_sort}</td>
    <td>
        <a href="index.php?p=admin&c=category&a=edit&id={$cat.id}">编辑</a>
        <a href="index.php?p=admin&c=category&a=delete&id={$cat.id}">删除</a>
    </td>
</tr>
{/foreach}
```

2. 在控制器中增加edit方法来实现指定分类的编辑，然后可以直接进行有效性验证（session）

```PHP
#CategoryController::edit()

//显示要编辑的分类信息
public function edit(){
    //接收数据验证合法性，强制转换成整型
    $id = (int)$_GET['id'];
    //有效性验证：判断当前分类ID是否在session中存在：不存在肯定无效
    if(!array_key_exists($id,$_SESSION['categories'])){
        //不存在
        $this->error('当前要编辑的分类不存在！','index');
    }
}
```

3. 将id分配给模板，并加载模板

```PHP
#CategoryController::edit()

//分配数据，加载模板
$this->assign('id',$id);
$this->display('categoryEdit.html');
```

4. 在模板中显示数据

```php+HTML
<!--categoryEdit.html-->
<form id="form2" name="form2" method="post" action="">
    <div class="st-form-line" style="z-index: 680;">
        <span class="st-labeltext">名称</span>
        <input name="c_name" type="text" class="st-forminput" style="width:510px" value="{$smarty.session.categories[$id].c_name}">
        <div class="clear" style="z-index: 670;"></div>
    </div>
    <div class="st-form-line" style="z-index: 640;">
        <span class="st-labeltext">父分类</span>
        <select name="c_parent_id" class="uniform">
            <option value="0">无</option>
            {foreach $smarty.session.categories as $cat}
            {*$smarty.session.categories[$id]表示取到当前要编辑的分类*}
            <option value="{$cat.id}" {if $cat.id == $smarty.session.categories[$id].c_parent_id}selected='selected'{/if}>{str_repeat('--',$cat['level'] * 2)}{$cat.c_name}</option>
            {/foreach}
        </select>
        <div class="clear"></div>
    </div>
    <div class="st-form-line" style="z-index: 680;">
        <span class="st-labeltext">排序</span>
        <input name="c_sort" type="text" class="st-forminput" style="width:510px" value="{$smarty.session.categories[$id].c_sort}">
        <div class="clear" style="z-index: 670;"></div>
    </div>
    <div class="button-box" style="z-index: 460;">
        <input type="submit" name="button" id="button" value="提交" class="st-button">
    </div>
</form>
```



#### **6.7 编辑无限极分类【更新分类】**



1. 编辑本身在后台是一种更新操作，分类编辑必然需要根据分类ID条件来实现更新，因此需要在显示给用户看的要编辑的分类form中增加一个要传递给后台的必要数据：分类ID，利用隐藏域实现

```php+HTML
<!--categoryEdit.html-->
<form id="form2" name="form2" method="post" action="">
    <input type="hidden" name="id" value="{$id}">
</form>
```

2. 要进行表单提交，要明确form表单提交的对象

```php+HTML
<!--categoryEdit.html-->
<form id="form2" name="form2" method="post" action="index.php?p=admin&c=category&a=update">
    <input type="hidden" name="id" value="{$id}">
</form>

<!--post表单提交也可以利用隐藏域来实现p，c和a参数提交-->
<form id="form2" name="form2" method="post" action="index.php">
    <input type="hidden" name="p" value="admin">
    <input type="hidden" name="c" value="category">
    <input type="hidden" name="a" value="update">
    <input type="hidden" name="id" value="{$id}">
</form>
```

3. 在控制器端，创建更新数据的方法，接收用户提交的数据

```PHP
#CategoryController::update()

//更新数据
public function update(){
    //利用数组接收数据：方便后续使用（主键除外）
    $id = (int)$_POST['id'];
    $data['c_name'] = trim($_POST['c_name']);
    $data['c_parent_id'] = (int)$_POST['c_parent_id'];
	$data['c_sort'] = trim($_POST['c_sort']);
}
```

4. 合法性验证：与新增时一样

```PHP
#CategoryController::update()

//合法性验证
if(empty($data['c_name'])){
    //当前自定义MVC框架没有提供回退功能，如果回到edit需要传递当前分类ID，如果要回到到编辑界面可以在公共控制器中增加一个back方法，如果不回去的话只能回到列表页面
	$this->error('分类名字不能为空！','index');
}

//排序必须为整数
if(!is_numeric($data['c_sort']) || (int)$data['c_sort'] != $data['c_sort'] || $data['c_sort'] < 0 || $data['c_sort'] > PHP_INT_MAX){
	$this->error('排序必须为一个正整数！','index');
}
```

5. 有效性验证：更新有可能更新名字，而名字更新后可能与当前指定的父分类下的其他分类同名，所以要进行同名验证（与新增验证逻辑不同）

```PHP
#CategoryController::update()

//有效性验证：确保不会在同一父类下出现同名分类
$c = new \admin\model\CategoryModel();
$cat = $c->checkCategoryName((int)$data['c_parent_id']),$data['c_name']);
if($cat && $cat['id'] != $id){
    //查到同名分类，且分类的id是自己，说明重名了
    $this->error('当前分类名字：' . $data['c_name'] . ' 在所选父分类下已经存在！','index');
}

```

6. 数据更新判定：为了减轻数据库的压力，可以先通过session判定是否有数据更新

```PHP
#CategoryController::update()

//通过session中对应的分类判定数组是否有不同的数据（用户有没有更新）:$data中有但后面数组不同，就保留
$data = array_diff_assoc($data,$_SESSION['categories'][$id]);

if(empty($data)){
    //没有不同的数据
    $this->error('没有要更新的内容！','index');	//也许用户不想更新
}
```

7. 数据更新：控制器调用模型更新数据

```PHP
#CategoryController::update()

//更新入库
if($c->autoUpdate($id,$data)){
    //更新成功
    $this->success('更新成功！','index');
}else{
    //更新失败
    $this->error('更新失败！','index');
}
```

8. 增加模型方法：因为当前是自动更新，而之前MVC中没有自动更新，所以可以把当前自动更新写到公共模型中去core/Model.php

```PHP
#Model.php

/*
 * 有主键的自动更新
 * @param1 int $id，主键值
 * @param2 array $data，要更新的数组，里面必须带主键字段
 * @return mixed ，成功返回受影响的行数（可能是0行），失败（错误）返回false
*/
public function autoUpdate(int $id,array $data){    
    //构造更新语句，注意where两侧的空格
    $where = ' where ' . $this->fields['key'] . ' = ' . $id;
    $sql = "update {$this->getTable()} set ";
    foreach($data as $k => $v){
        $sql .= $k . " = '{$v}',";
    }
    
    //去除最后多余的逗号“,”，构造完整SQL语句
    $sql = trim($sql,',') . $where;
    
    //执行SQL
    return $this->exec($sql);
}
```

9. 分类更新后要强制更新session中的分类信息，否则信息滞后（前提是显示session的首页CategoryController::Index()方法也使用了session）

```PHP
#CategoryController::update()更新成功后

//更新session中的数据
$_SESSION['categories'] = $c->getAllCategories();
```



#### **6.8 编辑无限极分类【完善】**

> **引入**：无限极分类是从指定分类（通常顶级）开始，然后逐层向下找到所有关联分类的（全部分类）。分类关联关系是通过字段c_parent_id来关联，分类在新增时是不会出现任何问题的，但是在编辑时，如果选择父分类的时候选择了自己或者自己的子分类，那么该分类就会形成永远的死循环（顶级分类）或者永远找不到（子分类指向自己的子分类）



1. 解决方案

* 方案1：事先解决问题，即在用户进行编辑时，分类不让选择自己以及自己的子分类（无限子分类）
  * 在进行分类获取的时候，将当前分类自己给禁止获取
  * 递归因为自己被禁，所有子分类也自动屏蔽
  * 用户在进行编辑时，看不到自己分类及其子分类
* 方案2：事后解决问题，即用户在提交更新后，判定用户的操作是否有效
  * 用户看到所有分类，并且可以选择自己及其子分类作为父分类
  * 用户提交信息给服务器
  * 服务器根据当前分类自己的ID找出所有的子分类（包括自己）
  * 判定当前分类是否在禁止选择的小无限极分类中

2. 应用方案1解决当前分类问题：在给用户选择之前，不是直接使用session中的全分类，而是在控制器中想办法让自身分类和子分类不再大分类中出现

   2.1利用原有模型方法实现能够控制哪些分类不获取（从而不获取其所有相关子分类），同时还不影响原来的功能

   * 给无限极分类函数增加禁止获取的分类id参数：$stop = 0，默认为0，表示不做任何禁止（因为没有分类的id为0的）
   * 在进行无限极分类判定的时候，判定分类是否属于禁止系列
   * 在递归调用时传入禁止分类ID

   ```PHP
   #CategoryModel::noLimitCategory()
   
   //1.参数修改
   /*
    * 无限极分类
    * @param1 array $categories，一个包含无限分类的数组
    * @param2 int $parent_id = 0，要确定从哪层开始寻找分类，默认为顶层，即找出所有分类
    * @param3 int $level = 0,当前得到的分类的有效层级，因为默认从顶级开始查，所以顶级的级别是0
    * @param4 int $stop = 0，表示不获取的分类，默认是0，即获取全部
    * @return array $list，分好类，同时每个分类添加了level元素的二维数组
   */
   public function noLimitCategory($categories,$parent_id = 0,$level = 0,$stop = 0){
       //因为寻找每次只能找一层：所以意味着找下层就要调用自己，应用递归，而跨方法保存数据需要使用静态变量
       static $list = array();
       
       //遍历数组：找出当前符合指定层次的分类
       foreach($categories as $cat){
           //2.逻辑修改：如果当前分类是禁止的，那么循环重新开始
           if($cat['c_id'] == $stop) continue;
           
           //当前分类的父分类id如果与要找的相同，当前分类就是目标分类
           if($cat['c_parent_id'] == $parent_id){
               //为当前分类添加上层级
               $cat['level'] = $level;
               //有效分类：保留在记录中，使用当前分类的ID作为数组的下标（方便以后其他应用）
               $list[$cat['id']] = $cat;
               
               //当前分类不一定是最终分类，可能还有子分类：应该找出所有的子分类，当前分类作为要找的分类的父分类，同时子分类对应的层级应该+1（递归点）
               //3.修改递归调用
               noLimitCategory($categories,$cat['id'],$level+1,$stop);
           }
       }
       
       //返回所有数据：最外层找顶层分类都找完了，数组遍历结束（递归出口）
       return $list;
   }
   ```

   **注意**：理论上来讲，应该将越常用的参数越靠前，但是为了不修改前面的逻辑，此处直接在后面追加参数

   2.2 控制器在进行编辑分类数据提供时，应该将原来数据进行一次新的无限极分类（数据筛选），然后分配给模板

   ```PHP
   #CategoryController::edit()
   
   //显示要编辑的分类信息
   public function edit(){
       //接收数据验证合法性，强制转换成整型
       $id = (int)$_GET['id'];
       //有效性验证：判断当前分类ID是否在session中存在：不存在肯定无效
       if(!array_key_exists($id,$_SESSION['categories'])){
           //不存在
           $this->error('当前要编辑的分类不存在！','index');
       }
       
       //1.修改分类信息：将禁止信息提供给分类
       $c = new \admin\model\CategoryModel();
       $categories = $c->noLimitCategory($_SESSION['categories'],0,0,$id);
       
       //分配数据，加载模板//2.分配数据给模板
       $this->assign('categories',$categories);
       $this->assign('id',$id);
       $this->display('categoryEdit.html');
   }
   
   ```

   2.3 在模板中修改显示数据源：不是直接从session读取全部，而是读取控制器分配的部分分类信息

   ```php+HTML
   <select name="c_parent_id" class="uniform">
       <option value="0">无</option>
       {foreach $categories as $cat}
       <option value="{$cat.id}" {if $cat.id == $categories[$id].c_parent_id}selected='selected'{/if}>{str_repeat('--',$cat['level'] * 2)}{$cat.c_name}</option>
       {/foreach}
   </select>
   ```






### **7. 博文管理功能**

> **引入**：博文管理是指后台用户对博文（自己的）进行增改查删（CURD）操作，其中普通用户只能针对自己的博文进行管理，而管理员可以对所有博文进行管理。



#### **7.1 博文数据表设计**



1. 博文表（b_article）包含字段如下

* id：自增长逻辑主键
* a_title：文章名字，varchar(20)类型
* a_content：文章内容，text类型
* c_id：分类的ID，int类型
* u_id：作者的ID，int类型
* a_author：作者名字，varchar(10)，冗余字段（逆规范化）
* a_time：发表时间，int类型时间戳（unsigned）
* a_status：文章状态，tinyint类型，1表示草稿（默认），2表示公开，3表示隐藏
* a_toped：是否置顶，tinyint类型，1表示不置顶（默认），2表示置顶
* a_img：封面图片名字，varchar(50)，默认为空字符串''
* a_img_thumb：缩略图名字，varchar(50)，默认为空字符串''
* a_is_delete：文章是否被删除（一般不会真正删除），tinyint类型，0表示正常（默认），1表示删除

2. 创建数据表

```Mysql
create table if not exists b_article(
	id int primary key auto_increment,
    a_title varchar(20) not null,
    a_content text not null,
    c_id int not null,
    u_id int not null,
    a_author varchar(10) not null,
    a_time int unsigned not null,
    a_status tinyint default 1 comment '1表示草稿，2表示公开，3表示隐藏',
    a_toped tinyint default 1 comment '1表示不置顶，2表示置顶',
    a_img varchar(50),
    a_img_thumb varchar(50),
    a_is_delete tinyint default 0 comment '0表示正常，1表示已删除'
)charset utf8;

```



#### **7.2 新增博文【显示表单】**



1. 在左侧菜单列表中，增加新增博文的操作入口，即点击链接，执行ArticleController::add()方法

```php+HTML
<!-- 博文管理 -->
<li class="subtitle">
 <a class="action tips-right" href="#" title="博文管理"><img src="{P}/img/icons/sidemenu/mail.png" width="16" height="16" alt="icon"/>博文管理<img src="{P}/img/arrow-down.png" width="7" height="4" alt="arrow" class="arrow" /></a>
 <ul class="submenu display-block">
    <li><a href="index.php?p=admin&c=article&a=add"><img src="{P}/img/icons/sidemenu/file_add.png" width="16" height="16" alt="icon"/>添加博文</a></li>
    <li><a href=""><img src="{P}/img/icons/sidemenu/file.png" width="16" height="16" alt="icon"/>博文列表</a></li>
    </ul>
</li>
<!-- 博文管理 -->
```

2. 增加博客控制器ArticleController，以及add方法加载模板：app/admin/controller/ArticleController::add()

```PHP
#博文控制器
namespace admin\controller;
use \core\Controller;

class ArticleController extends Controller{
    //添加博客：显示博客表单
    public function add(){
        
        //加载博客模板
        $this->display('articleAdd.html');
    }
}
```

3. 将博文相关模板放到app/admin/view/Article/目录下

![博客项目视图管理-后台博文](效果图\博客项目视图管理-后台博文.png)

4. 因为新增博文需要用到分类信息：需要在控制器中判定获取分类信息

```PHP
#articleController::add()

public function add(){
    //判定分类是否已经有
    if(!isset($_SESSION['categories'])){
        //没有：重新获取
        $c = new \admin\model\CategoryModel();
		$categories = $c->getAllCategories();
        
        //同时保存到session
        $_SESSION['categories'] = $categories;
    }
    
    //加载博客模板
    $this->display('articleAdd.html');
}
```

5. 在模板中显示所有的分类信息

```php+HTML
<select class="uniform" name="c_id">
    {foreach $smarty.session.categories as $cat}
    <option value="{$cat.c_id}">{str_repeat('--',$cat.level * 2)}{$cat.c_name}</option>
    {/foreach}
</select>
```

6. 修改模板静态资源即可



#### **7.3 新增博文【数据入库】**



1. 修改form表单提交项：articleAdd.html

```php+HTML
<form id="form2" name="form2" method="post" action="index.php?p=admin&c=article&a=insert">                         
</form>
```

2. 在控制器中增加对应的数据插入方法ArticleController::insert()

```PHP
#ArticleController::insert()

//新增博文入库
public function insert(){
    
}
```

3. 接收数据：因为表单名字与数据库表字段一致，可以直接接收全部post数据

```PHP
#ArticleController::insert()

//接收数据
$data = $_POST;
```

4. 数据合法性验证：标题、内容不能为空，分类ID必须存在

```PHP
#ArticleController::insert()

//合法性验证：标题和内容
if(empty(trim($data['b_title'])) || empty(trim($data['b_content']))){
    $this->error('博文标题和内容都不能为空！','add');
}
//分类ID验证
if(!array_key_exists($data['c_id'],$_SESSION['categories'])){
    //分类ID不存在
    $this->error('当前分类不存在！','add');
}
```

5. 博文中还有其他必要数据需要补充，而这些数据是存在于session中或者其他信息中，如用户信息、博文时间等

```PHP
#ArticleController::insert()

//补充必要数据：用户id，用户名、录入时间
$data['u_id'] = $_SESSION['user']['u_id'];
$data['a_author'] = $_SESSION['user']['u_username'];
$data['a_time'] = time();
```

6. 理论上讲，现在应该实现用户的文件上传和缩略图制作，但是此时先完成其他步骤（文件上传和缩略图不影响步骤继续进行）。因此可以进行数据的入库操作：调用模型进行数据插入（自动插入）

```PHP
#ArticleController::insert()

//数据入库
$a = new \admin\model\ArticleModel();
if($a->autoInsert($data)){
    //数据插入成功：去列表页
    $this->success('博文插入成功！','index');
}else{
    //数据插入失败
    $this->error('博文插入失败！','add');
}
```

7. 增加博文模型：app/admin/model/ArticleModel

```PHP
#ArticleModel
namespace admin\model;
use \core\Model;

class ArticleModel extends Model{
    //表名
	protected $table = 'article';
}
```

8. 我们在博文模型中，没有增加自动插入autoInsert功能，可以在基础模型Model中去实现（所有模型继承共用）

```PHP
#Model

//自动入库：要求提供的数组的下标与数据表对应的字段对应，否则报错
public function autoInsert($data){
    //组织SQL部分：insert into 表名 (字段列表) values(值列表)；
    $fields = $values = '';
    
    //从数组中构造字段列表和值列表，为了安全，从表字段去获取
    foreach($this->fields as $key => $value){
        //排除主键重复
        if($key == 'key') continue;
        
        //判定当前字段在要操作的数组中是否存在
        if(array_key_exists($key,$data)){
            //存在：可以使用原始数据
            //字段保留逗号，值要增加引号，也保留逗号
            $fields .= $value . ',';
            $values .= "'" . $data[$v] . "',";
        }
    }
    
    //去除最右边的逗号
    $fields = rtrim($fields,',');
    $values = rtrim($values,',');
    
    //拼凑SQL指令
    $sql = "insert into {$this->getTable()} ({$fields}) values ({$values})";
    
    //执行SQL
    return $this->exec($sql);
}
```





#### **7.4 博文列表**



1. 在左侧菜单列表中，增加博文列表的操作入口，即点击链接，执行ArticleController::index()方法

```php+HTML
<!-- 博文管理 -->
<li class="subtitle">
 <a class="action tips-right" href="#" title="博文管理"><img src="{P}/img/icons/sidemenu/mail.png" width="16" height="16" alt="icon"/>博文管理<img src="{P}/img/arrow-down.png" width="7" height="4" alt="arrow" class="arrow" /></a>
 <ul class="submenu display-block">
    <li><a href="index.php?p=admin&c=article&a=add"><img src="{P}/img/icons/sidemenu/file_add.png" width="16" height="16" alt="icon"/>添加博文</a></li>
    <li><a href="index.php?p=admin&c=article"><img src="{P}/img/icons/sidemenu/file.png" width="16" height="16" alt="icon"/>博文列表</a></li>
    </ul>
</li>
<!-- 博文管理 -->
```

2. 在博文控制器中增加index方法，实现获取所有的博文信息

```PHP
#ArticleController::index()

//获取所有博文信息
public function index(){
    //调用模型获取全部博文信息
    $a = new \admin\model\ArticleModel();
    $articles = $a->getArticleInfo();
    
    //分配模板并调用模板
    $this->assign('articles',$articles);
    $this->display('articleIndex.html');
}
```

3. 在博文模型中增加方法获取博文简易信息：ID、作者名字、分类名称、标题、发布日期、评论数量、状态

```PHP
#ArticleModel::getArticleInfo()

/* 
 * 获取博文基本信息
 * @param1 array $cond = array()，查询条件数组，字段名为下标，条件包含标题、分类、状态、置顶和作者
 * @param2 int $pagecount = 5，每次获取的数量
 * @param3 int $page = 1，分页页码
 */
public function getArticleInfo(array $cond = array(),int $pagecount = 5,int $page = 1){
    //构造基础条件where：所有查询出来的结果应该都是未“删除”的
    $where = ' where a_is_delete = 0 ';
    
    //判定条件：如果条件存在则增加一个条件选项
    foreach($cond as $k => $v){
        //判定字段，根据不同字段来制定方案
        switch($k){
            case 'a_title':
                $where .= " and a_title like '%{$v}%'";
                break;
            case 'c_id':
            case 'a_status':
            case 'a_toped':
            case 'u_id':
                //都是使用=符号进行条件筛选，可以统一用
                $where .= " and {$k} = {$v}";
                break;
        }
    }
    
    //计算分页信息
    $offset = ($page - 1) * $pagecount;
    
    //构造完整SQL：不同数据在不同表中，所以要用到别名（暂时不做评论数量）
    $sql = "select a.id,a.a_title,a.a_author,a.time,a.a_status,c.c_name 
    from {$this->getTable()} a 
    left join {$this->getTable('category')} c 
    on a.c_id = c.id {$where} 
    order by a_time desc 
    limit {$offset},{$pagecount}";
    
    //执行SQL
    return $this->query($sql,true);
}
```

4. 在模板中显示数据

```php+HTML
<!--articleIndex.html-->
{foreach $articles as $art}
<tr>
    <td>{$art.id}</td>
    <td>{$art.a_author}</td>
    <td>{$art.c_name}</td>
    <td><a href="#">{$art.a_title}</a></td>
    <td>{date('Y-m-d',$art['a_time'])}</td>
    <td>12</td>
    <td>{if $art.a_status eq 1}草稿{elseif $art.a_status eq 2}公开{else}隐藏{/if}</td>
    <td>
        <a href="#">删除</a>
        {if $art.a_author eq $smarty.session.user.u_username}
        <a href="#">编辑</a>
        {/if}
    </td>
</tr>
{foreachelse}
<tr>
    <td colspan="8">没有符合条件的博文</td>
</tr>
{/foreach}
```



#### **7.5 博文检索**

> **引入**：很多数据显示较多的地方，通常都会提供一些检索条件，允许用户使用检索条件来实现数据的筛选或者精确匹配。



1. 找到检索表单，发现表单中有如下筛选条件：标题、分类、状态、置顶，其实还有一个默认筛选：用户（超级管理员除外），在以上信息中，分类是需要提供好的，因此先需要在控制器中获取分类信息

```PHP
#ArticleController::index()

//获取分类信息并存入session（获取列表数据之后）
if(!isset($_SESSION['categories'])){
    $c = new \admin\model\CategoryModel();
    $_SESSION['categories'] = $c->getAllCategories();
}
```

2. 在检索表单中显示所有分类信息：注意默认显示的是任意分类

```php+HTML
<!--articleIndex.html-->
<div class="st-form-line" style="z-index: 640;">
   <span class="st-labeltext">分类</span>
   <select class="uniform" name="c_id">
       <option value="0">任意</option>
       {foreach $smarty.session.categories as $cat}
       <option value="{$cat.c_id}" {if isset($cond['c_id']) && $cond['c_id'] eq $cat.c_id} selected="selected"{/if}>{str_repeat('--',$cat.level * 2)}{$cat.c_name}</option>
       {/foreach}
   </select>
   <div class="clear"></div>
</div>
```

3. 修改表单提交对象：提交到当前请求自己，所以可以不用修改form表达的action选项，用户可以直接点击form表单的提交按钮，实现数据的提交
4. 后台接收可能存在的筛选条件：在列表功能实现之前，先接收条件数据（注意是可能存在）

```PHP
#ArticleController::index()

//接收条件：所有代码之前，利用数组接收
$cond = array();	
//判定接收：判定有数据且数据有效，才做条件
if(isset($_REQUEST['a_title']) && trim($_REQUEST['a_title'])) $cond['a_title'] = trim($_REQUEST['a_title']);
if(isset($_REQUEST['c_id']) && (int)$_REQUEST['c_id']) $cond['c_id'] = (int)$_REQUEST['c_id'];
if(isset($_REQUEST['a_status']) && (int)$_REQUEST['a_status']) $cond['a_status'] = (int)$_REQUEST['a_status'];
if(isset($_REQUEST['a_toped']) && (int)$_REQUEST['a_toped']) $cond['a_toped'] = (int)$_REQUEST['a_toped'];

//用户条件筛选：如果普通用户，只能看到自己的
if(!$_SESSION['user']['u_is_admin']) $cond['u_id'] = $_SESSION['user']['id']; 
```

5. 因为模型获取数据时已经考虑到条件了，所以只需要将条件传入控制器调用的模型方法即可

```PHP
//调用模型获取全部博文信息，在获取条件之后
$a = new \admin\model\ArticleModel();
$articles = $a->getArticleInfo($cond);
```

6. 为了让用户看到自己条件查询的结果，需要在检索表单上回显用户的表单数据

```php+HTML
<!--articleIndex.html-->
<form id="form2" name="form2" method="post" action="">
   <div class="st-form-line" style="z-index: 680;">
       <span class="st-labeltext">标题</span>
       <input name="a_title" type="text" class="st-forminput" style="width:510px" value="{if isset($cond['a_title'])}{$cond['a_title']}{/if}">
       <div class="clear" style="z-index: 670;"></div>
   </div>
   <div class="st-form-line" style="z-index: 640;">
       <span class="st-labeltext">分类</span>
       <select class="uniform" name="c_id">
           <option value="0">任意</option>
           {foreach $smarty.session.categories as $cat}
           <option value="{$cat.c_id}" {if isset($cond['c_id']) && $cond['c_id'] eq $cat.c_id} selected="selected"{/if}>{str_repeat('--',$cat.level * 2)}{$cat.c_name}</option>
           {/foreach}
       </select>
       <div class="clear"></div>
   </div>
   <div class="st-form-line">
       <span class="st-labeltext">状态</span>
       <select class="uniform" name="a_status">
           <option value="">任意</option>
           <option value="1" {if isset($cond['a_status']) && $cond['a_status'] eq 1}selected="selected"{/if}>草稿</option>
           <option value="2" {if isset($cond['a_status']) && $cond['a_status'] eq 2}selected="selected"{/if}>公开</option>
           <option value="3" {if isset($cond['a_status']) && $cond['a_status'] eq 3}selected="selected"{/if}>隐藏</option>
       </select>
       <div class="clear"></div>
   </div>
   <div class="st-form-line" style="z-index: 620;">
       <span class="st-labeltext">置顶</span>
       <label class="margin-right10">
           <div class="radio">
               <span><input type="radio" name="a_toped" class="uniform" value="" ></span>
           </div> 不限
       </label>
       <label class="margin-right10">
           <div class="radio">
               <span><input type="radio" name="b_toped" class="uniform" value="1" {if isset($cond['a_toped']) && $cond['a_toped'] eq 1}checked="checked"{/if}></span>
           </div> 置顶
       </label>
       <label class="margin-right10">
           <div class="radio">
               <span><input type="radio" name="b_toped" class="uniform" value="2" {if isset($cond['a_toped']) && $cond['a_toped'] eq 2}checked="checked"{/if}></span>
           </div> 不置顶
       </label>

       <div class="clear" style="z-index: 610;"></div>
   </div>
   <div class="button-box" style="z-index: 460;">
       <input type="submit" name="button" id="button" value="提交" class="st-button">
   </div>
</form>
```



#### **7.5 删除博文**



1. 在博文列表页中，增加删除操作链接，请求：ArticleController::delete($id)

```php+HTML
<td>
    <a href="index.php?p=admin&c=article&a=delete&id={$art.id}">删除</a>
    {if $art.a_author eq $smarty.session.user.u_username}
    <a href="#">编辑</a>
    {/if}
</td>
```

2. 通常删除操作属于不可逆操作，因此可以通过js给用户增加一个容错处理：删除提示

```php+HTML
<td>
    <a href="index.php?p=admin&c=article&a=delete&id={$art.id}" onClick="return confirm('确认删除当前博文：{$art.a_title}？')">删除</a>
    {if $art.a_author eq $smarty.session.user.u_username}
    <a href="#">编辑</a>
    {/if}
</td>
```

3. 在博文控制器中增加一个对应的处理方法实现删除操作

```PHP
#ArticleController::delete()

//删除博文
public function delete(){
    //接收数据
    $id = (int)$_GET['id'];
    
    //调用模型删除数据
    $a = new \admin\model\ArticleModel();
    if($a->deleteArticle($id)){
        $this->success('博文删除成功！','index');
    }else{
        $this->error('博文删除失败！','index');
    }
}
```

4. 在博文模型中增加方法：ArticleModel::deleteArticle()

```PHP
#ArticleModel::deleteArticle()

//"删除"数据
public function deleteArticle($id){
    //构建SQL指令
    $sql = "update {$this->getTable()} set a_is_delete = 1 where id = {$id}";
    
    //执行
    return $this->exec($sql);
}
```



#### **7.6 编辑博文【显示表单】**



1. 在博文列表页中，增加编辑操作链接，请求：ArticleController::edit($id)

```php+HTML
<td>
    <a href="index.php?p=admin&c=article&a=delete&id={$art.id}">删除</a>
    {if $art.a_author eq $smarty.session.user.u_username}
    <a href="index.php?p=admin&c=article&a=edit&id={$art.id}">编辑</a>
    {/if}
</td>
```

2. 在博文控制器中增加edit方法，并实现数据的获取，以及模板调用

```PHP
#ArticleController::edit()

//编辑博文：显示博文
public function edit(){
    //接收数据
    $id = (int)$_GET['id'];
    
    //获取博文数据
    $a = new \admin\model\ArticleModel();
    $art = $a->getById($id);				//公共模型方法
    
    //判定
    if(!$art) $this->error('当前要编辑的博文不存在！','index');
    
    //获取分类
    if(!isset($_SESSION['categories'])){
        $c = new \admin\model\CategoryModel();
        $_SESSION['categories'] = $c->getAllCategories();
    }
    
    //分配模板调用模板
    $this->assign('art',$art);
    $this->display('articleEdit.html');
}
```

3. 在模板中显示数据

```php+HTML
<form id="form2" name="form2" method="post" action="" enctype="multipart/form-data">
    <div class="st-form-line" style="z-index: 680;">
        <span class="st-labeltext">标题</span>
        <input name="b_title" type="text" class="st-forminput" style="width:510px" value="{$art.a_title}">
        <div class="clear" style="z-index: 670;"></div>
    </div>
    <div class="st-form-line">
        <span class="st-labeltext">发布日期</span>
        <!-- start default date picker -->
                                
        <input type="text" id="datepicker" class="datepicker-input" style="width:180px;" value="{date('Y-m-d',$art.a_time)}" readonly >
        <!-- end default date picker -->
        <div class="clear" style="z-index: 510;"></div>
    </div>
    <div class="st-form-line" style="z-index: 640;">
        <span class="st-labeltext">分类</span>
        <select class="uniform" name="c_id">
            {foreach $smarty.session.categories as $cat}
            <option value="{$cat.c_id}" {if $cat.c_id eq $art.c_id}selected="selected"{/if}>{str_repeat('--',$cat.level * 2)}{$cat.c_name}</option>
            {/foreach}
        </select>
        <div class="clear"></div>
    </div>
    <div class="st-form-line">
        <span class="st-labeltext">状态</span>
        <select class="uniform" name="b_status">
            <option value="1" {if $art.a_status eq 1}selected="selected"{/if}>草稿</option>
            <option value="2" {if $art.a_status eq 2}selected="selected"{/if}>公开</option>
            <option value="3" {if $art.a_status eq 3}selected="selected"{/if}>隐藏</option>
        </select>
        <div class="clear"></div>
    </div>
    <div class="st-form-line" style="z-index: 620;">
        <span class="st-labeltext">置顶</span>
        <label class="margin-right10">
            <div class="radio">
                <span><input type="radio" name="b_toped" class="uniform" value="1" {if $art.a_toped eq 1}checked{/if}></span>
            </div> 置顶
        </label>
        <label class="margin-right10">
            <div class="radio">
                <span><input type="radio" name="b_toped" class="uniform" value="2" {if $art.a_toped eq 2}checked{/if}></span>
            </div> 不置顶
        </label>

        <div class="clear" style="z-index: 610;"></div>
    </div>
    <div class="st-form-line">
        <span class="st-labeltext">图片</span>
        <img src="{URL}uploads/{$art.b_img}">
        <div class="clear"></div>
    </div>
    <div class="st-form-line">
        <span class="st-labeltext">新图片</span>
        <input type="file" name="b_img">
        <div class="clear"></div>
    </div>

    <!-- START jWYSIWYG TEXT EDITOR -->
    <div class="simplebox grid740">
        <div class="titleh">
            <h3>内容</h3>
        </div>
        <div class="body">
            <textarea class="st-forminput" rows="5" cols="47" name="b_content" style="width:96.5%;">{$art.a_content}</textarea>
        </div>

    </div>
    <!-- END jWYSIWYG TEXT EDITOR -->

    <div class="button-box" style="z-index: 460;">
        <input type="submit" name="button" id="button" value="提交" class="st-button">
    </div>
</form>
```





#### **7.7 编辑博文【更新博文】**



1. 修改编辑博文表单的form表单提交对象：ArticleController::update()

```php+HTML
<!--articleEdit.html-->
<form id="form2" name="form2" method="post" action="index.php?p=admin&c=article&a=update" enctype="multipart/form-data">
</form>
```

2. 因为更新操作是基于当前博文ID来实现的，所以还需要增加博文ID传递给后台PHP

```php+HTML
<!--articleEdit.html-->
<form id="form2" name="form2" method="post" action="index.php?p=admin&c=article&a=update">
    <input type="hidden" name="id" value="{$art.id}">
</form>
```

3. 数据更新后提交给后台，在后台增加一个更新方法：ArticleController::update()

```PHP
#ArticleController::update

//编辑博文：更新数据
public function update(){
    //接收数据
    $id = (int)$_POST['id'];
    $data['a_title'] = trim($_POST['a_title']);
    $data['c_id']    = (int)$_POST['c_id'];
    $data['a_status']= (int)$_POST['a_status'];
    $data['a_toped'] = (int)$_POST['a_toped'];
    $data['a_content'] = trim($_POST['a_content']);
    
    //数据合法性判定
    if(empty($data['a_title']) || empty($data['a_content'])){
        //此时应该回退到上级编辑界面：增加公共方法back()
        $this->back('博文的标题和内容都不能为空！');
    }
}
```

4. 在公共控制器增加back方法，回到上级界面

```PHP
#Controller.php

//回退到上级界面
public function back($msg,$time = 3){
    header("refresh:{$time};url={$_SERVER['HTTP_REFERER']}");
    echo $msg;
    exit;
}
```

5. 从用户角度来讲，有内容更新才叫更新（读操作比写操作效率高），因此可以先把原始数据查出来进行数据对比，然后再进行相似内容剔除，最后才更新

```PHP
#ArticleController::update()

//调用模型获取当前数据（合法性判定后）
$a = new \admin\model\ArticleModel();
$art = $a->getById($id);

//数据比较
$data = array_diff_assoc($data,$art);

//判定
if(!$data){
    $this->error('没有要更新的内容！','index');
}

//更新
if($a->autoUpdate($id,$data)){
    $this->success('更新成功！','index');
}else{
    $this->error('更新失败！','index');
}
```



### **8. 辅助功能**

> **引入**：在进行博文新增时，并没有进行文件上传处理以及图片处理（缩略图），在文件列表时，我们虽然在后台进行了数据分页，但是在前端显示上也没有实现真正数据分页。这些文件上传功能、图片处理功能和分页功能，都可以做成工具来方便开发使用。



#### **8.1 文件上传工具【工具类】**



1. 在vendor下创建文件上传类，使用命名空间：vendor/Uploader.php

```PHP
#Uploader.php
namespace vendor;

class Uploader{
    
}
```

2. 增加属性保存允许上传的类型，并提供更改的方法（静态）

```PHP
#Uploader.php

//静态属性：保存允许上传的类型MIME类型，默认为jpg图片
private static $types = array('image/jpg','image/jpeg','image/pjpeg');

//方法设定类型
public static function setTypes(array $types){
    if(!empty($types)) self::$types = $types;
}
```

3. 创建单文件上传方法（静态），确定参数信息

```PHP
#Uploader

//静态属性：保存可能出现的错误信息
public static $error;

/*
 * 上传单个文件
 * @param1 array $file，要上传的单个文件信息
 * @param2 string $path，存储路径
 * @param3 int $max = 2000000，限定大小，默认2M
 * @return mixed，成功返回新的文件名字，失败返回false
*/
public static function uploadOne(array $file,string $path,int $max = 2000000){
    
}
```

4. 判定有效性

```PHP
#Uploader::uploadOne()

//判定文件有效性：是数组，而且有5个上传文件要素
if(!isset($file['error']) || count($file) != 5){
	self::$error = '无效上传文件！';
	return false;
}

//判定存储路径是否存在
if(!is_dir($path)){
    self::$error = '文件存储路径不存在！';
	return false;
}

//判定文件是否正确上传
switch($file['error']){
	case 1:
	case 2:
		self::$error = '文件超过服务器允许大小！';
		return false;
	case 3:
		self::$error = '文件只有部分被上传！';
		return false;
	case 4:
		self::$error = '没有选中要上传的文件！';
		return false;
	case 6:
	case 7:
		self::$error = '服务器错误！';
		return false;
}

//判定文件类型是否允许上传
if(!in_array($file['type'],self::$types)){
	self::$error = '当前文件类型不允许上传！';
	return false;
}

//判定文件是否超出当前用户允许大小
if($file['size'] > $max){
    self::$error = '当前只允许上传：' . $max . '字节，当前文件超过限定大小！';
	return false;
}
```

5. 获取新文件名字：给出文件名，获取随机名字，此时应该使用一个新的方法来实现（以后其他地方可以用）

```PHP
#Uploader::uploadOne()

//获取新名字
$filename = self::getRandomName($file['name']);
```

```PHP
#Uploader::getRandomName()

//根据原有名字生成新名字（后缀不变）：名字有当前时间类型 + YmdHis + 随机6位大写字母组成
public static function getRandomName(string $filename,$prefix = 'image'){
	//获取后缀
	$ext = strrchr($filename,'.');	//带.

	//生成随机名字
	$newname = $prefix . date('YmdHis');	//image前缀 + 日期时间部分

	//增加随机字符（6位大写字母）
	for($i = 0;$i < 6;$i++){
		$newname .= chr(mt_rand(65,90));
	}

	//返回完整名字
	return $newname . $ext;
}
```

6. 完成文件移动保存，并返回结果

```PHP
#Uploader::uploadOne()

//移动文件，并判定移动结果
if(move_uploaded_file($file['tmp_name'], $path . '/' . $filename)){
	return $filename;
}else{
	self::$error = '文件移动失败！';
	return false;
}
```



#### **8.2 文件上传工具【使用】**



1. 找到需要进行文件上传的位置调用文件上传类：ArticleController::insert()

```PHP
#ArticleController::insert()

//文件上传（补充了入库数据之后）
if($a_img = \vendor\Uploader::uploadOne($_FILES['a_img'],PUBLIC_PATH . 'uploads')){
	//有文件上传
	$data['a_img'] = $a_img;			
}
```

2. 判定修改：数据操作成功之后，对文件上传操作进行一个提示

```PHP
#ArticleController::insert()

//数据入库
$a = new \admin\model\ArticleModel();
if($a->autoInsert($data)){
    //数据插入成功：去列表页//如果文件上传失败，给出提示
    if(!$a_img) $this->success('博文插入成功！但是图片上传失败！失败原因：' . \vendor\Uploader::$error,'index');
    $this->success('博文插入成功！','index');
}else{
    //数据插入失败//重来之前，将已经上传的文件干掉
    @unlink(PUBLIC_PATH . 'uploads/' . $a_img);
    $this->error('博文插入失败！','add');
}
```



#### **8.3 图片处理工具【工具类】**



1. 在vendor下创建图片处理类，使用命名空间：vendor/Image.php

```PHP
#Image.php
namespace vendor;

class Image{}
```

2. 增加能够处理的后缀信息：用来动态确定图片资源操作函数

```PHP
#Image.php

//图片后缀对应的处理函数：GD库
private static $ext = array(
		'jpg' => 'jpeg',
		'jpeg'=> 'jpeg',
		'png' => 'png',
		'gif' => 'gif'
	);
```

3. 创建缩略图制作方法，确定参数信息

```PHP
#Image::makeThumb()

//静态属性，保存错误信息
public static $error;
/*
 * 根据图片制作缩略图
 * @param1 string $file，要制作缩略图的资源路径
 * @param2 string $path，存储路径
 * @param3 int $width = 90，缩略图宽
 * @param4 int ￥height = 90，缩略图高
 * @return miexd，成功返回文件名，失败返回false
*/
public static function makeThumb($file,$path,$width = 90,$height = 90){
}
```

4. 判定资源有效性：图片存在，存储路径

```PHP
#Image::makeThumb()

//判定文件是否存在
if(!file_exists($file)){
	self::$error = '原图文件不存在！';
	return false;
}

//判定路径是否存在
if(!is_dir($path)){
	self::$error = '存储路径不存在！';
	return false;
}
```

5. 获取图片相关信息，判定文件是否满足制作缩略图条件（是不是指定图片类型）

```PHP
#Image::makeThumb()

//打开原图资源
$file_info = pathinfo($file);	//包含文件名filename，后缀extension，路径dirname 
$img_info = getimagesize($file);//包含文件宽高信息

//判定文件能否制作缩略图
if(!array_key_exists($file_info['extension'], self::$ext)){
	//文件的后缀不在允许操作的后缀里
	self::$error = '当前文件类型不能制作缩略图！';
	return false;
}
```

6. 构造函数资源：明确使用哪个gd函数

```PHP
#Image::makeThumb()

//指定操作的图片函数
$open = 'imagecreatefrom' . self::$ext[$file_info['extension']]; //imagecreatefromjpeg
$close = 'image' . self::$ext[$file_info['extension']];
```

7. 打开图片资源和缩略图资源

```php
#Image::makeThumb()

//打开原图资源
$src = $open($file);
$thumb = imagecreatetruecolor($width, $height);

//缩略图背景补白
$bg = imagecolorallocate($thumb, 255, 255, 255);
imagefill($thumb, 0, 0, $bg);
```

8. 计算原图在缩略图的位置，通过宽高比来算

```PHP
#Image::makeThumb()

//补白计算：计算宽高比
$src_b = $img_info[0] / $img_info[1];
$thumb_b = $width / $height;

//原图宽高比大于缩略图：原图太宽，缩略图的宽度要占满
if($src_b > $thumb_b){
	//缩略图实际宽高
	$w = $width;
	$h = ceil($width / $src_b);

	//缩略图起始位置
	$x = 0;
	$y = ceil(($height - $h) / 2);
}else{
    //原图宽高比小于缩略图：原图太高，缩略图的高度要占满
	$w = ceil($src_b * $width);
	$h = $height;

	$x = ceil(($width - $w) / 2);
	$y = 0;
}
```

9. 复制合并：制作缩略图

```PHP
#Image::makeThumb()

//采样复制合并
if(!imagecopyresampled($thumb, $src, $x, $y, 0, 0, $w, $h, $img_info[0], $img_info[1])){
	self::$error = '缩略图制作失败！';
	return false;
}
```

10. 保存，销毁资源，返回数据

```PHP
#Image::makeThumb()

//保存图片到指定位置：原名前面加上thumb_前缀
$res = $close($thumb,$path . 'thumb_' . $file_info['basename']);

//销毁资源
imagedestroy($src);
imagedestroy($thumb);

//根据结果判定返回数据
if($res){
	return 'thumb_' . $file_info['basename'];
}else{
	self::$error = '缩略图保存失败！';
	return false;
}

```



#### **8.4 图片处理工具【使用】**



1. 在文件上传成功之后，应该调用图片处理类来实现缩略图制作

```PHP
#ArticleController::insert()

//文件上传（补充了入库数据之后）
if($a_img = \vendor\Uploader::uploadOne($_FILES['a_img'],UPLOAD_PATH)){
	//有文件上传
	$data['a_img'] = $a_img;
    
    //缩略图制作：注意要使用图片路径而不是名字
    $data['a_img_thumb'] = \vendor\Image::makeThumb(UPLOAD_PATH . $a_img,PUBLIC_PATH . 'uploads');
}
```

2. 如果操作错误，在给用户提示时，可以给出错误信息

```php
#ArticleController::insert()

//数据入库
$a = new \admin\model\ArticleModel();
if($a->autoInsert($data)){
    //数据插入成功：去列表页//如果文件上传失败，给出提示
    if(!$a_img) $this->success('博文插入成功！但是图片上传失败,失败原因：' . \vendor\Uploader::$error,'index');
    //如果缩略图制作失败，给出提示
    if(!$data['a_img_thumb']) $this->success('博文插入成功！但是缩略图制作失败，失败原因：' . \vendor\Image::$error,'index');
    $this->success('博文插入成功！','index');
}else{
    //数据插入失败//重来之前，将已经上传的文件干掉
    @unlink(PUBLIC_PATH . 'uploads/' . $a_img);
    $this->error('博文插入失败！','add');
}
```



#### **8.5 分页处理工具【工具类】**

> **引入**：分页几乎是所有网站都会用到的功能，分页工具分为两种类型：不带数据分页和带数据分页，通常带数据分页的话比较复杂，不够简洁。而不带数据分页的设计比较简单，只关注业务，不涉及具体数据。



1. 在vendor下创建分页处理类，使用命名空间：vendor/Page.php

```PHP
#Page.php
namespace vendor;

class Page{
    
}
```

2. 创建分页方法，实现京东分页功能：产生分页li标签，确定参数数据

```PHP
#Page::clickPage()

/*
 * 分页功能：百度分页
 * @param1 string $url，基本链接（http://www.blog.com/index.php)
 * @param2 int $counts，记录数量
 * @param3 int $pagecount = 10，每页记录数，默认每页10条
 * @param4 int $page = 1，当前页码，默认第1页
 * @param5 array $cond = array()，连接资源：a条件，c条件，p条件，其他查询条件
 	array('a' => 'index','c' => 'article', 'p' => 'admin')
*/
public static function clickPage(string $url,int $counts,int $pagecount = 10,int $page = 1,array $cond = array()){
    
}
```

3. 计算上一页，下一页页码，以及拼凑url链接

```PHP
#Page::clickPage()

//计算页码
$pages = ceil($counts / $pagecount);		//总页数
$prev = $page > 1 ? $page - 1 : 1;			//最小第1页
$next = $page < $pages ? $page + 1 : $pages;//最大最后一页

//组织条件：路径条件
$pathinfo = '';
foreach($cond as $k => $v){
    $pathinfo .= $k . '=' . $v . '&';
}
```

4. 生成li标签信息，京东链接逻辑如下

* 一共显示7个可点击页面（数字页面，上一页和下一页除外）
* 如果总页数小于7，直接显示所有页面
* 如果总页数大于7
  * 用户当前选择的页数小于5，显示前7页，后面增加`...`
  * 用户选择的页数大于6，显示1和2页，然后`...`以及被选择的页面前后各2页，后面增加`...`
  * 用户选择的页数大于6，如果页码属于最后5页，那么只有中间一个`...`

```PHP
#Page::clickPage()

//组织分页li标签
//1.最左侧的上一页功能
$click = "<li><a href='{$url}?{$pathinfo}page={$prev}'>上一页</a></li>";

//2.中间的数字页码点击功能
if($pages <= 7){
    //2.1可以全部显示完
    for($i = 1;$i <= $pages;$i++){
        $click .= "<li><a href='{$url}?{$pathinfo}page={$i}'>{$i}</a></li>";
    }
}else{
    //2.2页码总数超过7页，说明会存在...：根据当前页码来设定
    // 用户点击页码在5以内：显示前7页，后面增加...
    if($page <= 5){
        //2.2.1 组织前7页
       	for($i = 1;$i <= $pages;$i++){
        	$click .= "<li><a href='{$url}?{$pathinfo}page={$i}'>{$i}</a></li>";
       	}
        //增加...
        $click .= "<li><a href='#'>...</a></li>";
    }else{
        //2.2.2 选的页码大于5，显示前两页，后跟...
        $click .= "<li><a href='{$url}?{$pathinfo}page=1'>1</a></li>";
        $click .= "<li><a href='{$url}?{$pathinfo}page=1'>1</a></li>";
        $click .= "<li><a href='#'>...</a></li>";
        
        //要判定当前选择的页码是否是最后几页：最后是否增加...
        if($pages - $page <= 3){
            //2.2.2.1 当前页码已经选的是最后3页，显示后面5页即可
            for($i = $pages - 4;$i <= $pages; $i++){
                $click .= "<li><a href='{$url}?{$pathinfo}page={$i}'>{$i}</a></li>";
            }
        }else{
            //2.2.2.2 当前页码选的为中间段：显示当前页码前后各两页，并且最后增加...
            for($i = $page - 2;$i <= $page + 2;$i++){
               $click .= "<li><a href='{$url}?{$pathinfo}page={$i}'>{$i}</a></li>"; 
            }
            //增加尾部...
            $click .= "<li><a href='#'>...</a></li>";
        }
    }
}

//3.补充下一页
$click = "<li><a href='{$url}?{$pathinfo}page={$next}'>下一页</a></li>";

//返回得到的分页链接
return $click;
```



#### **8.6 分页处理工具【使用】**



1. 在显示博文界面，有分页功能：在控制器调用分页功能，并分配给模板

```PHP
#ArticleController::index()

//在分配变量给模板调用模板之前
$pagestr = \vendor\Page::clickPage($url,$counts,$pagecount,$page,$cond);
//分配给模板
$this->assign('pagestr',$pagestr);
```

2. 发现缺失数据：基础访问url，当前检索条件下的分页数量，每页显示的数据量，页码和各项条件。此时需要在调用前获取上述数据

* $url：利用URL常量和index.php文件字符串即可
* $counts：需要利用模型根据条件去数据表查询
* $pagecount：需要定义或者从配置文件读取（前提是有配置）
* $page：需要当前方法接收用户选择的页码
* $cond：需要在当前用户对于数据的检索条件之外，额外补充访问信息：a、c和p信息

```PHP
#ArticleController::index()

//接收分页信息（在接收数据前后都可以）
$page = (int) $_REQUEST['page'] ?? 1;
//获取或者设定配置信息，默认5条
global $config;
$pagecount = $config['admin']['article_pagecount'] ?? 5;

//获取总记录数：根据筛选条件筛选（在模型获取数据之后）
$counts = $art->getSearchCounts($cond);		//$cond为原来检索条件
```

3. 在模型中增加相应的获取数量的方法

```PHP
#ArticleModel::getSearchCounts()

//根据条件获取记录数量
public function getSearchCounts($cond = array()){
    //构造基础条件where：所有查询出来的结果应该都是未“删除”的
    $where = ' where a_is_delete = 0 ';
    
    //判定条件：如果条件存在则增加一个条件选项
    foreach($cond as $k => $v){
        //判定字段，根据不同字段来制定方案
        switch($k){
            case 'a_title':
                $where .= " and a_title like '%{$v}%'";
                break;
            case 'c_id':
            case 'a_status':
            case 'a_toped':
            case 'u_id':
                //都是使用=符号进行条件筛选，可以统一用
                $where .= " and {$k} = {$v}";
                break;
        }
    }
    
    //构造SQL获取条件对应记录数
    $sql = "select count(*) c from {$this->getTable()} {$where}";
    $res = $this->query($sql);
    
    //返回结果
    return $res['c'] ?? 0;
}
```

4. 修改博文列表数据获取条件：统一分页信息

```PHP
#ArticleController::index()

//调用模型获取全部博文信息，在获取条件之后（分页部分修改）
$a = new \admin\model\ArticleModel();
//$articles = $a->getArticleInfo($cond);	//原数据
$articles = $a->getArticleInfo($cond,$pagecount,$page);
```

5. 完成分页工具类的调用：补充数据条件，条件曾增加a、c和p参数

```PHP
#ArticleController::index()

//在分配变量给模板调用模板之前
$cond['a'] = A;
$cond['c'] = C;
$cond['p'] = P;
$pagestr = \vendor\Page::clickPage(URL . 'index.php',$counts,$pagecount,$page,$cond);
```

6. 在模板中显示分页信息

```php+HTML
<ul class="pagination">
    {$pagestr}
</ul>
```





### **9. 用户管理功能**

> **引入**：用户管理是指后台管理员对当前用户信息的增删查操作。



#### **9.1 新增用户【显示表单】**



1. 在左侧菜单列表中，增加新增用户的操作入口，即点击链接，执行UserController::add()方法

```php+HTML
<!-- 用户管理 -->
<li class="subtitle">
    <a class="action tips-right" href="#" title="用户管理"><img src="{P}/img/icons/sidemenu/user.png" width="16" height="16" alt="icon"/>用户管理<img src="{P}/img/arrow-down.png" width="7" height="4" alt="arrow" class="arrow" /></a>
    <ul class="submenu display-block">
        <li><a href="index.php?p=admin&c=user&a=add"><img src="{P}/img/icons/sidemenu/user_add.png" width="16" height="16" alt="icon"/>添加用户</a></li>
        <li><a href="#"><img src="{P}/img/icons/sidemenu/file.png" width="16" height="16" alt="icon"/>用户列表</a></li>
    </ul>
</li>
<!-- 用户管理 -->
```

2. 增加用户控制器，并增加add方法，实现表单数据的显示

```PHP
#UserController
namespace admin\controller;
use \core\Controller;

class UserController extends Controller{
    //新增用户：显示表单
	public function add(){
		$this->display('userAdd.html');
	}
}
```

3. 将用户相关视图放到app/admin/view/User/目录下，并修改userAdd.html的静态资源



#### **9.2 新增用户【数据入库】**



1. 修改表单提交对象：UserController::insert()

```php+HTML
<form id="form2" name="form2" method="post" action="index.php?p=admin&c=user&a=insert">
</form>
```

2. 在控制器端创建数据入库方法，进行数据接收和合法性校验：UserController::insert()

```PHP
#UserController::insert()

//新增用户：数据入库
public function insert(){
    //接收数据
    $data = $_POST;
    
    //数据验证
    if(empty(trim($data['u_username'])) || empty(trim($data['u_password']))){
        $this->error('用户名和密码都不能为空！','add');
    }
    
    //补充注册时间
    $data['u_reg_time'] = time();
}
```

3. 验证用户名的有效性：不能同名

```PHP
#UserController::insert()

//验证用户名是否存在
$u = new \admin\model\UserModel();
if($u->checkUsername($data['u_username'])){
    //用户名已经存在
    $this->error('当前用户名：' . $data['u_username'] . ' 已经存在！','add');
}
```

4. 在用户模型中增加验证用户名字的方法

```PHP
#UserModel::checkUsername()

//验证用户名是否存在
public function checkUsername(string $username){
    $sql = "select id from {$this->getTable()} where u_username = '{$username}'";
    return $this->query($sql);
}
```

5. 如果用户名验证没有问题，进行数据录入数据库操作

```PHP
#UserController::insert()

//数据入库：记得密码要进行md5加密
$data['u_password'] = md5($data['u_password']);
if($u->autoInsert($data)){
    //新增成功：去列表页查看
    $this->success('用户新增成功！','index');
}else{
    //新增失败：重新新增
    $this->error('用户新增失败！','add');
}
```





#### **9.3 用户列表**



1. 在左侧菜单列表中，增加用户用户的操作入口，即点击链接，执行UserController::index()方法

```php+HTML
<!-- 用户管理 -->
<li class="subtitle">
    <a class="action tips-right" href="#" title="用户管理"><img src="{P}/img/icons/sidemenu/user.png" width="16" height="16" alt="icon"/>用户管理<img src="{P}/img/arrow-down.png" width="7" height="4" alt="arrow" class="arrow" /></a>
    <ul class="submenu display-block">
        <li><a href="index.php?p=admin&c=user&a=add"><img src="{P}/img/icons/sidemenu/user_add.png" width="16" height="16" alt="icon"/>添加用户</a></li>
        <li><a href="index.php?p=admin&c=user"><img src="{P}/img/icons/sidemenu/file.png" width="16" height="16" alt="icon"/>用户列表</a></li>
    </ul>
</li>
<!-- 用户管理 -->
```

2. 增加控制器方法：调用模型获取所有用户信息，并且分配给模板

```PHP
#UserController::index()

//显示所有用户信息
public function index(){
    //调用模型获取所有用户信息
    $u = new \admin\model\UserModel();
    $users = $u->getAllUsers();
    
    //分配模板
    $this->assign('users',$users);
    $this->display('userIndex.html');
}
```

3. 在模型中增加获取所有用户的方法

```PHP
#UserModel::getAllUsers()

/*
 * 获取所有用户信息：根据分页获取
 * @param1 int $pagecount = 5,每页获取数据
 * @param2 int $page = 1，当前页码
 * @return mixed，成功返回二维数组，失败返回false
*/
public function getAllUsers($pagecount = 5,$page = 1){
    //分析分页数据
    $offset = ($page - 1) * $pagecount;
    //组织SQL并执行
    $sql = "select * from {$this->getTable()} order by u_reg_time desc limit {$offset},{$pagecount}";
    return $this->query($sql);
}
```

4. 在模板中显示所有用户数据

```php+HTML
<!--userIndex.html-->
{foreach $users as $user}
<tr>
    <td>{$user@key + 1}</td>
    <td>{$user.u_username}</td>
    <td>{if $user.u_is_admin eq 1}管理员{else}普通用户{/if}</td>
    <td>{date('Y-m-d',$user.u_reg_time)}</td>
    <td>
        <a href="#">删除</a>
    </td>
</tr>
{/foreach}
```

5. 增加分页功能：接收分页信息、获取记录总数、生成分页链接并分配给模板

```PHP
#UserController::index()

//最开始接收数据
$page = $_REQUEST['page'] ?? 1;

//数据接收和判定之后获取每页显示数据
global $config;
$pagecount = $config['admin']['user_pagecount'] ?? 5;

//修改模型调用方法：getAllUsers()
$users = $u->getAllUsers($pagecount,$page);
//获取总记录数
$counts = $u->getCounts();

//调用分页工具类：组织条件
$cond['a'] = A;
$cond['c'] = C;
$cond['p'] = P;
$pagestr = \vendor\Page::clickPage(URL . 'index.php',$counts,$pagecount,$page,$cond);

//分配给模板
$this->assign('pagestr',$pagestr);
```

6. 在模型中增加获取记录数的方法

```PHP
#UserModel::getCounts()

//获取记录数
public function getCounts(){
    //组织SQL并执行
    $sql = "select count(*) c from {$this->getTable()}";
    $res = $this->query($sql);
    return $res['c'] ?? 0;
}
```

7. 在模板中显示分页链接

```php+HTML
<!--userIndex.html-->
<ul class="pagination">
    {$pagestr}
</ul>
```



#### **9.4 删除用户**



1. 在用户列表中，给每位用户增加操作链接：UserController::delete()

```php+HTML
<!--userIndex.html-->
{foreach $users as $user}
<tr>
    <td>{$user@key + 1}</td>
    <td>{$user.u_username}</td>
    <td>{if $user.u_is_admin eq 1}管理员{else}普通用户{/if}</td>
    <td>{date('Y-m-d',$user.u_reg_time)}</td>
    <td>
        <a href="index.php?p=admin&c=user&a=delete&id={$user.id}">删除</a>
    </td>
</tr>
{/foreach}
```

2. 为了防止误操作，增加js防止误操作确认功能

```php+HTML
<!--userIndex.html-->
{foreach $users as $user}
<tr>
    <td>{$user@key + 1}</td>
    <td>{$user.u_username}</td>
    <td>{if $user.u_is_admin eq 1}管理员{else}普通用户{/if}</td>
    <td>{date('Y-m-d',$user.u_reg_time)}</td>
    <td>
        <a href="index.php?p=admin&c=user&a=delete&id={$user.id}" onClick="return confirm('确认删除当前用户：' + {$user.u_username} + '?')">删除</a>
    </td>
</tr>
{/foreach}
```

3. 在控制器增加相应的处理方法

```PHP
#UserController::delete()

//删除用户
public function delete(){
    //接收数据
    $id = (int)$_GET['id'];
    
    //调用模型删除
    $u = new \admin\model\UserModel();
    if($u->deleteById($id)){
        //删除成功
        $this->success('删除成功！','index');
    }else{
        //删除失败
        $this->error('删除失败！','index');
    }
}
```



## **四、 项目前台实现**



### **1. 首页功能**



#### **1.1 首页博文显示**

1. 增加前台首页控制器：app/home/controller/IndexController::index()

```PHP
#IndexController::index()
namespace home\controller;
use \core\Controller;

class IndexController extends Controller{
    
    //前台首页
    public function index(){
        
        //模板加载
        $this->display('blogShowList.html');
    }
}

```

2. 在前台将模板进行视图分类操作（app/home/view/Index/），并修改相应静态资源
3. 获取博文信息：控制器调用模型获取博文信息，同样有分页信息和检索条件，然后分配给模板

```PHP
#IndexController::index()

//获取博文信息：在模板加载之前
$a = new \home\model\ArticleModel();
$articles = $a->getAllArticles();

//分配数据到模板
$this->assign('articles',$articles);
```

3. 增加前台部分的博文模型：/app/home/model/ArticleModel.php

```PHP
#ArticleModel.php
namesapce home\model;
use \core\Model;

class ArticleModel extends Model{
	//增加表名
    protected $table = 'article';
    
    /* 
     * 获取博文详细信息
     * @param1 array $cond = array()，查询条件数组，字段名为下标，条件包含标题、分类
     * @param2 int $pagecount = 5，每次获取的数量
     * @param3 int $page = 1，分页页码
     */
    public function getAllArticles(array $cond = array(),int $pagecount = 5,int $page = 1){
        //构造基础条件where：所有查询出来的结果应该都是未“删除”的
        $where = ' where a_is_delete = 0 ';

        //判定条件：如果条件存在则增加一个条件选项
        foreach($cond as $k => $v){
            //判定字段，根据不同字段来制定方案
            switch($k){
                case 'a_title':
                    $where .= " and a_title like '%{$v}%'";
                    break;
                case 'c_id':
                    //都是使用=符号进行条件筛选，可以统一用
                    $where .= " and {$k} = {$v}";
                    break;
            }
        }

        //计算分页信息
        $offset = ($page - 1) * $pagecount;

        //构造完整SQL：获取博文的id，标题，内容，作者名字，图片，发布时间和分类名字
        $sql = "select a.id,a.a_title,a.a_author,a.time,c.c_name 
        from {$this->getTable()} a 
        left join {$this->getTable('category')} c 
        on a.c_id = c.id {$where} 
        order by a_time desc 
        limit {$offset},{$pagecount}";

        //执行SQL
        return $this->query($sql,true);
    }
    
}
```

4. 在模板中显示所有数据

```php+HTML
<!--blogShowList.html-->
<!-- Post -->
{foreach $articles as $art}
<article class="post-item">
  <a href="#" class="post-thumb waves-effect">
    <img src="http://localhost/web/public/{if empty($art.a_img)}home/img/blog/post01.jpg{else}uploads/{$art.a_img}{/if}">
  </a><!-- .post-thumb -->
  <div class="post-body">
    <div class="post-meta">
      <div class="column">
        <span>
          <i class="icon-head"></i>
          <a href="#">{$art.a_author}</a>
        </span>
        <span>在</span>
        <span>
          <i class="icon-ribbon"></i>
          <a href="#">{$art.c_name}</a>
        </span>
        <span>下发布</span>
        <span class="post-comments">
          <i class="icon-speech-bubble"></i>
          <a href="#">12</a>
        </span>
      </div>
      <div class="column"><span>{date('Y-m-d',$art.a_time)}</span></div>
    </div><!-- .post-meta -->
    <h3 class="post-title">{$art.a_title}</h3>
    <p>{$art.a_content}</p>
    <a href="#">点击阅读更多</a>
  </div><!-- .post-body -->
</article><!-- .post-item -->
```

5. 获取所有分类信息，并进行展示

```PHP
#IndexController::index()

//获取博文信息之后获取分类信息：存入session
@session_start();
if(!isset($_SESSION['categories'])){
    $c = new \home\model\CategoryModel();
	$_SESSION['categories'] = $c->getAllCategories();
}
```

6. 增加前台部分的分类模板：/app/home/model/CategoryModel.php（可以直接使用后台的简化版）

```PHP
#CategoryModel
namespace home\model;
use \core\Model;


class CategoryModel extends Model{
	//表名
	protected $table = 'category';

	//获取所有分类
	public function getAllCategories(){
		$sql = "select * from {$this->getTable()} order by c_sort desc";
		$cats = $this->query($sql,true);

		//没有进行分类统计
		return $this->noLimitCategory($cats);
	}

	//无限极分类：因为不存在修改（即控制器访问）可以私有化
	private function noLimitCategory(array $cats,$parent_id = 0,$level = 0){
		//静态变量保存数据
		static $res = array();
	
		foreach($cats as $cat){
			if($cat['c_parent_id'] == $parent_id){
				$cat['level'] = $level;
				$res[$cat['c_id']] = $cat;

				//递归
				$this->noLimitCategory($cats,$cat['c_id'],$level + 1);
			}
		}
		//返回数据
		return $res;
	}
}
```

7. 在模板中显示所有的分类信息

```php+HTML
<!--blogShowList.html-->
<ul>
  {foreach $smarty.session.categories as $cat}
  <li><a href="#">{str_repeat('--',$cat.level * 2)}{$cat.c_name}<span>3</span></a></li>
  {/foreach}
</ul>
```

8. 在控制器中获取所有分类下对应的博文数量信息

* 可以在获取分类的时候直接连接查询获取：耦合较大
* 可以单独对博文进行分类统计获取：使用灵活（推荐）

```PHP
#IndexController::index()

//获取分类对应的博文数量：在获取分类之后
$cat_counts = $a->getCountsByCategory();
//分配给模板
$this->assign('cat_counts',$cat_counts);
```

9. 增加模型方法获取分类对应的博文数量

```PHP
#ArticleModel::getCountsByCategory()

//获取分类下对应的博文数量
public function getCountsByCategory(){
    //组织SQL并执行
    $sql = "select c_id,count(*) c from {$this->getTable()} where a_is_delete = 0 group by c_id";
    //执行
    $res = $this->query($sql,true);
    
    //遍历成目标结果：分类作为下标
   	$list = array();
    foreach($res as $v){
        //$v代表每隔分类对应的数量数组
      	$list[$v['c_id']] = $v['c'];
    }
    
    //返回结果
    return $list;
}
```

10. 在模板中显示分类对应的博文数量

```php+HTML
<!--blogShowList.html-->
<!--blogShowList.html-->
<ul>
  {foreach $smarty.session.categories as $cat}
  <li><a href="#">{str_repeat('--',$cat.level * 2)}{$cat.c_name}<span>{$cat_counts[$cat.id]|default:0}</span></a></li>
  {/foreach}
</ul>
```

11. 获取最新的三条博文基本信息并展示

```php
#IndexController::index()

//在获取博文之后
$news = $a->getNewsInfo();

//分配给模板
$this->assign('news',$news);
```

12. 在模型中获取最新3条记录（可变）

```PHP
#ArticleModel::getNewsInfo();

//获取最新3条记录（可变条数）
public function getNewsInfo(int $limit = 3){
    //组织SQL：获取id、标题、缩略图
    $sql = "select id,a_title,a_img_thumb from {$this->getTable()} order by a_time desc limit {$limit}";
    return $this->query($sql,true);
}
```

13. 在模板中显示最新的博文信息

```php+HTML
<!--blogShowList.html-->
{foreach $news as $new}
<div class="item">

  <div class="thumb">
    <a href="#"><img src="http://localhost/web/public/{if empty($new.a_img_thumb)}{P}/img/blog/sidebar/post01.jpg{else}uploads/thumb/{$new.a_img_thumb}{/if}" alt="Post01"></a>
  </div>
  <div class="info">
    <h4><a href="#">{$new.a_title}</a></h4>
  </div>
</div><!-- .item -->
{/foreach}
```



#### **1.2 首页博文检索功能**

> **引入**：首页博文检索分为两个部分：分类点击检索和标题模糊匹配，两种检索都是请求IndexController::index()方法，然后进行条件检索。



1. 分类检索：给分类增加点击链接，请求IndexController::index()

```php+HTML
<!--blogShowList.html-->
<!--blogShowList.html-->
<ul>
  {foreach $categories as $cat}
  <li><a href="index.php?c_id={$cat.id}">{str_repeat('--',$cat.level * 2)}{$cat.c_name}<span>3</span></a></li>
  {/foreach}
</ul>
```

2. 在控制器中接收条件，并且将条件添加到获取数据的模型方法中

```PHP
#IndexController::index()

//在最开始接收条件
$cond = array();
if(isset($_GET['c_id'])) $cond['c_id'] = (int)$_GET['c_id'];

//修改获取博文的模型方法调用
$articles = $a->getAllArticles($cond);
```

3. 标题检索：因为标题检索form表单就是提交给当前方法，所以不需要修改表单提交对象，直接在后台接收数据，并且加入到模型获取数据即可

```PHP
#IndexController::index()

//在最开始接收条件
$cond = array();
if(isset($_GET['c_id'])) $cond['c_id'] = (int)$_GET['c_id'];
if(isset($_REQUEST['a_title'])) $cond['a_title'] = trim($_REQUEST['a_title']);
```

4. 数据回显：分类是本身就全列出来，如果有样式区分那么采用即可，如果没有的话不用刻意回显；但是标题检索可以回显到表单元素中

```PHP
#ArticleController::index()

//分配检索条件给模板
$this->assign('cond',$cond);
```

```php+HTML
<!--blogShowList.html-->
<form method="post" class="search-box">
  <input type="text" name="a_title" class="form-control" placeholder="按标题搜索博文" {if isset($cond.a_title)}value="{$cond.a_title}"{/if}>
  <button type="submit"><i class="icon-search"></i></button>
</form>
```



#### **1.3 首页博文分页**



1. 前台控制器接收分页数据，并且读取配置文件的分页数据

```PHP
#IndexController::index()

//在最开始接收分页数据
$page = $_REQUEST['page'] ?? 1;
//读取分页量
global $config;
$pagecount = $config['home']['article_pagecount'] ?? 5;
```

2. 获取博文记录数：被删除的博文不获取

```PHP
#IndexController::index()

//在获取博文之后获取记录数（检索条件）
$counts = $a->getCounts($cond);
```

3. 在模型端增加记录获得方法

```PHP
#ArticleModel::getCounts()

//根据条件获取博文记录数
public function getCounts(array $cond = array()){
    //确定where条件
    $where = ' where a_is_delete = 0 ';
    //其他条件
    foreach($cond as $k => $v){
        //判定字段，根据不同字段来制定方案
        switch($k){
            case 'a_title':
                $where .= " and a_title like '%{$v}%'";
                break;
            case 'c_id':
                //都是使用=符号进行条件筛选，可以统一用
                $where .= " and {$k} = {$v}";
                break;
        }
    }
    
    //拼凑完整指令
    $sql = "select count(*) as c from {$this->getTable()} {$where}";
    //执行
    $res = $this->query($sql);
    return $res['c'] ?? 0;
}
```

4. 在获取博文的时候，传入分页数据条件

```PHP
#IndexController::index()

//修改获取博文
$articles = $a->getAllArticles($cond,$pagecount,(int)$page);
```

5. 调用分页类获取分页字符串

```PHP
#IndexController::index()

//在分配调用视图前//不用刻意增加cond条件，因为刻意利用默认a,c和p
$pagestr = \vendor\Page::clickPage(URL . 'index.php',$counts,$pagecount,$page,$cond);
```

6. 在模板中显示分页字符串

```php+HTML
<!--blogShowList.html-->

<!-- Pagination -->
<ul class="pagination">
   {$pagestr}
   {*如果需要按下面方式显示数据，可以在控制器中分配相关数据，然后显示*}
   <!--<li>共有 16 条记录,每页显示 3 条记录， 当前为 1/6</li>-->
</ul>
```



### **2. 用户管理功能**

> **引入**：用户管理可以与后台共用一张用户表，不需要额外设计表。前台用户主要有登录和注册功能。



#### **2.1 用户登录功能**



1. 用户登录表单已经在首页显示的时候隐藏了，不需要额外请求。因此只需要修改隐藏的form登录表单提交对象即可

```php+HTML
<!--blogShowList.html-->
<h4>登录</h4>
<form method="post"  action="index.php?c=user&a=check">
  <input type="u_username" class="form-control" placeholder="请您填写用户名" name="u_username" required>
  <input type="u_password" class="form-control" placeholder="请您填写密码" name="u_password" required>
  <div class="form-group">
    <button type="submit" class="btn login-btn btn-default waves-effect waves-light">立刻登录<i class="icon-head"></i></button>
  </div>
  <div class="text-left">
    <span class="text-sm text-semibold">新用户? <a href="#" data-toggle="modal" data-target="#registerModal">立即注册</a></span>
  </div>
</form><!-- <form> -->
```

2. 在后台创建处理用户功能的控制器，并增加处理用户登录的check方法。/app/home/controller/UserController::check()

```PHP
#UserController.php
namespace home\controller;
use \core\Controller;

class UserController extends Controller{
    
    //用户登录
    public function check(){
        //接收用户数据
        $u_username = trim($_POST['u_username']);
        $u_password = trim($_POST['u_password']);
        
        //合法性验证
        if(empty($u_username) || empty($u_password)){
            //错误：必须明确回到首页（当前是User控制器）
            $this->error('用户名和密码都不能为空！','index','Index');
        }
    }
}
```

3. 验证用户的有效性：用户名验证，用户密码后验证，成功信息记录到session

```PHP
#UserController::check()

//验证用户名是否存在
$u = new \home\model\UserModel();
if(!$user = $u->checkUsername($u_username)){
    $this->error('当前用户名不存在！','index','Index');
}
```

4. 增加前台用户模型，并增加验证用户名的方法

```PHP
#UserModel.php
namespace home\model;
use \core\Model;

class UserModel extends Model{
    //表名
    protected $table = 'user';
    
    //验证用户名
    public function checkUsername($username){
        $sql = "select * from {$this->getTable()} where u_username = '{$username}'";
        return $this->query($sql);
    }
}
```

5. 验证用户密码：md5加密

```PHP
#UserController::check()

//验证用户名之后
if($user['u_password'] !== md5($u_password)){
    $this->error('密码错误！','index','Index');
}
```

6. 成功信息提示，重新回到首页

```PHP
#UserController::check()

//登录成功
@session_start();
$_SESSION['user'] = $user;、
$this->success('登录成功！','index','Index');
```

7. 在模板中显示用户登录后应该看到的内容

```php+HTML
<!--blogShowList.html-->
<div class="toolbar">            
  {if isset($smarty.session.user)}
  <a href="#" class="text-sm">退出登录</a>
  <a href="index.php?p=admin" class="btn btn-sm btn-default btn-icon-right waves-effect waves-light">{$smarty.session.user.u_username} <i class="icon-head"></i></a>
  {else}
  <a href="#">class="btn btn-sm btn-default btn-icon-right waves-effect waves-light" data-toggle="modal" data-target="#loginModal">立刻登录 <i class="icon-head"></i></a>
  {/if}
</div><!-- .toolbar -->
```



#### **2.2 用户退出功能**



1. 增加用户点击链接：在用户登录成功后，会有一个`退出登录`链接，增加URL

```php+HTML
<!--blogShowList.html-->
<div class="toolbar">            
  {if isset($smarty.session.user)}
  <a href="index.php?a=logout&c=user" class="text-sm">退出登录</a>
  <a href="index.php?p=admin" class="btn btn-sm btn-default btn-icon-right waves-effect waves-light">{$smarty.session.user.u_username} <i class="icon-head"></i></a>
  {else}
  <a href="#" class="btn btn-sm btn-default btn-icon-right waves-effect waves-light" data-toggle="modal" data-target="#loginModal">立刻登录 <i class="icon-head"></i></a>
  {/if}
</div><!-- .toolbar -->
```

2. 增加控制器方法，处理退出功能

```PHP
#UserController::logout()

//退出系统
public function logout(){
    //销毁session即可 
    @session_start();
    session_destroy();
    
    //跳转到首页
    $this->success('退出成功！','index','index');
}
```



#### **2.3 用户注册功能**



1. 注册表单在首页中也已经直接到浏览器端，因此只需要修改表单提交对象即可

```php+HTML
<!--blogShowList.html-->
<h4>注册</h4>
<form method="post"  action="index.php?c=user&a=register">
  <input name="u_username" type="text" class="form-control" placeholder="请您填写用户名" required>
  <input name="u_password" type="password" class="form-control" placeholder="请您填写密码" required>
  <div class="form-group">
    {*验证码*}
    <img src="index.php?c=user&a=captcha" width="300px" heigth="60px" onclick="this.src='index.php?c=user&a=captcha&'+Math.random()">
  </div>
  <input name="captcha" type="text" class="form-control" placeholder="请您填写验证码" required>
  <div class="form-group">
    <button type="submit" class="btn login-btn btn-default waves-effect waves-light">立刻注册<i class="icon-head"></i></button>
  </div>
  <div class="text-left">
    <span class="text-sm text-semibold">已注册? <a href="#" data-toggle="modal" data-target="#loginModal">立即登录</a></span>
  </div>
</form><!-- <form> -->
```

2. 后台生成验证码

```PHP
#UserController::captcha()

//获取验证码
public function captcha(){
    //调用验证码类生成验证码
    \vendor\Captcha::getCaptcha();
}
```

3. 后台注册功能：包括接收数据，合法性验证，用户名和验证码有效性验证，数据入库

```PHP
#UserController::register()

//注册功能
public function register(){
    //数据接收
    $data['u_username'] = trim($_POST['u_username']);
    $data['u_password'] = trim($_POST['u_password']);
    $captcha = trim($_POST['captcha']);
    
    //合法性验证
    if(empty($captcha)){
        $this->error('验证码不能为空！','index','index');
    }
    if(empty($data['u_username']) || empty($data['u_password'])){
        $this->error('用户名和密码不能为空！','index','index');
    }
    
    //有效性验证：验证码和用户名
    if(!\vendor\Captcha::checkCaptcha($captcha)){
        $this->error('验证码错误！','index','index');
    }
    //用户名判定：尝试获取用户名
    $u = new \home\model\UserModel();
    if($->checkUsername($data['u_username'])){
        $this->error('当前用户名：' . $datat['u_username'] . ' 已经存在！','index','index');
    }
    
    //补充数据：数据入库
    $data['u_reg_time'] = time();
    if($u->autoInsert($data)){
        $this->success('注册成功！','index','index');
    }else{
        $this->error('注册失败！','index','index');
    }
}
```



### **3. 博文明细功能**



#### **3.1 显示博文明细**



1. 博文明细有多个入口：列表和右侧最新博文

```php+HTML
<!--blogShowList.html-->
{foreach $articles as $art}
<article class="post-item">
  <a href="index.php?a=detail&id={$art.id}" class="post-thumb waves-effect">
    <img src="http://localhost/web/public/{if empty($art.a_img)}home/img/blog/post01.jpg{else}uploads/{$art.a_img}{/if}">
  </a><!-- .post-thumb -->
  <div class="post-body">
    <div class="post-meta">
      <div class="column">
        <span>
          <i class="icon-head"></i>
          <a href="#">{$art.a_author}</a>
        </span>
        <span>在</span>
        <span>
          <i class="icon-ribbon"></i>
          <a href="#">{$art.c_name}</a>
        </span>
        <span>下发布</span>
        <span class="post-comments">
          <i class="icon-speech-bubble"></i>
          <a href="#">12</a>
        </span>
      </div>
      <div class="column"><span>{date('Y-m-d',$art.a_time)}</span></div>
    </div><!-- .post-meta -->
    <h3 class="post-title">{$art.a_title}</h3>
    <p>{$art.a_content}</p>
    <a href="index.php?a=detail&id={$art.id}">点击阅读更多</a>
  </div><!-- .post-body -->
</article><!-- .post-item -->

<!--最新博文-->
{foreach $news as $new}
<div class="item">
  <div class="thumb">
    <a href="#"><img src="http://localhost/web/public/{if empty($new.a_img_thumb)}{P}/img/blog/sidebar/post01.jpg{else}uploads/thumb/{$new.a_img_thumb}{/if}" alt="Post01"></a>
  </div>
  <div class="info">
    <h4><a href="index.php?a=detail&id={$art.id}">{$new.a_title}</a></h4>
  </div>
</div><!-- .item -->
{/foreach}
```

2. 在控制器中增加方法接收数据、获取博文信息，然后分配给模板

```PHP
#IndexController::detail()

//显示博文明细
public function detail(){
    //接收数据
    $id = (int)$_GET['id'];
    
    //获取文章
    $a = new \home\model\ArticleModel();
    $article = $a->getById($id);
    
    //开启session
    @session_start();
    
    //分配数据
    $this->assign('article',$article);
    $this->display('blogShow.html');
}
```

3. 在模板中显示数据

```php+HTML
<!--blogShow.html-->
<h1>{$art.b_title}</h1>
<div class="post-meta">
  <div class="column">
    <span>
      <i class="icon-head"></i>
      <a href="#">{$art.a_author}</a>
    </span>
    <span>在</span>
    <span>
      <i class="icon-ribbon"></i>
      <a href="#">{$smarty.session.categories[$art.c_id]}</a>
    </span>
    <span>下发布</span>
    <span class="post-comments">
      <i class="icon-speech-bubble"></i>
      <a href="#">12</a>
    </span>
  </div>
  <div class="column"><span>{date('Y m d',$art.a_time)}</span></div>
</div><!-- .post-meta -->
{if isset($art.a_img)}
<img src="uploads/{$art.a_img}">
{/if}
<p>{$art.a_content}</p>
```



### **4. 评论功能**

> **引入**：评论是基于博文本身存在的，在前台用户可以查看博文评论，以及发表评论（需要登录），在后台可以对所有评论进行查看和删除。



#### **4.1 评论数据表设计**



1. 评论表（b_comment）包含以下字段

* id：主键自增长
* c_comment：变长varchar(50)不为空，评论长度不允许超过50个字符
* c_time：int评论时间
* u_id：int评论用户的ID
* a_id：int评论所属博文ID

2. 创建评论表

```Mysql
create table if not exists b_comment(
	id int primary key auto_increment,
    c_comment varchar(50) not null,
    c_time int unsigned not null,
    u_id int unsigned not null,
    a_id int unsigned not null
)charset utf8;
```





#### 4.2 **新增评论**



1. 新增评论：新增评论是在博文明细后提供一个评论框，该框需要确认用户已经登录（博客用户）才能进行评论。先在博文明细静态页中给用户进行权限判定

```php+HTML
<!--blogShow.html-->
<h4 class="comment-reply-title">发布新评论</h4>
<form method="post" id="comment-form" class="comment-form" action="">
  <div class="form-group">
    <label for="cf_comment" class="sr-only">Comment</label>
    <textarea name="c_comment" id="cf_comment" class="form-control input-alt" rows="7" placeholder="输入您的评论"></textarea>
  </div>            
  <p class="form-submit">
    {if isset($smarty.session.user)}
    <input name="submit" type="submit" id="submit" class="btn btn-primary btn-block" value="发布">
    {else}
    <input type="button" onclick="JavaScript:return false" class="btn btn-primary btn-block" value="请先登录">
    {/if}
  </p>
</form>
```

2. 确认表单提交对象：CommentController::insert()

```php+HTML
<!--blogShow.html-->
<form method="post" id="comment-form" class="comment-form" action="index.php&c=comment&a=insert">
</form>
```

3. 考虑到后期在进行评论入库的时候，需要用到评论对应的博客ID，因此需要在表单中隐藏一个表单，提交博文ID

```php+HTML
<!--blogShow.html-->
<form method="post" id="comment-form" class="comment-form" action="index.php&c=comment&a=insert">
    <input type="hidden" name="a_id" value="{$art.id}">
</form>
```

4. 创建评论控制器并创建insert方法：/app/home/controller/CommentController::insert()

```PHP
#CommentController.php
namespace home\controller;
use \core\Controller;

class CommentController extends Controller{
    
    //博文入库
    public function insert(){
        
    }
}
```

5. 接收数据，完成验证，然后入库

```PHP
#CommentController::insert()

//接收数据
$data['a_id'] = (int)$_POST['a_id'];
$data['c_comment'] = trim($_POST['c_comment']);

//验证
if(empty($data['c_comment']) || mb_strlen($data['c_comment']) > 50){
    $this->back('评论内容不能为空！且评论长度不能超过50个字符！');
}

//补充数据入库
@session_start();
$data['u_id'] = $_SESSION['user']['id'];
$data['c_time'] = time();

//入库
$c = new \home\model\CommentModel();
if($c->autoInsert($data)){
    $this->back('评论成功！');
}else{
    $this->back('评论失败！');
}
```

6. 创建对应模型，因为当前调用的方法为公共模型方法，所以不需要额外增加方法

```PHP
#CommentModel.php
namespace home\model;
use \core\Model;

class CommentModel extends Model{
    //属性
    protected $table = 'comment';
}
```



#### **4.3 显示评论**



1. 在博文明细控制器方法中，获取当前博文对应的全部评论

```PHP
#IndexController::detail()

//在获取博文之后获取博文对应所有评论
$c = new \home\model\CommentModel();
$comments = $c->getCommentsByArticle($id);

//分配给模板
$this->assign('comments',$comments);
```

2. 在评论模型中，获取所有评论信息

```PHP
#CommentModel::getCommentsByArticle()

//获取博文对应的所有评论
public function getCommentsByArticle($a_id){
    //组织SQL
    $sql = "select c.*,u.u_username from {$this->getTable()} c left join {$this->getTable('user')} u on c.u_id = u.id where c.a_id = {$a_id} order by c.c_time desc";
    
    //执行
    return $this->query($sql,true);
}
```

3. 在模板中显示所有评论信息

```php+HTML
<!--blogShow.html-->
<h4 class="comments-count">共有{count($comments)}条评论</h4>
<!-- Comment -->
{foreach $comments as $comment}
<div class="comment">
  <div class="comment-meta">
    <div class="column">
      <span class="comment-autor"><i class="icon-head"></i><a href="#">{$comment.u_username}</a></span>
    </div>
    <div class="column">
      <span class="comment-date">{date('H:i:s d.m.Y',$comment.c_time)}</span>
    </div>
  </div><!-- .comment-meta -->
  <div class="comment-body">
    <p>{$comment.c_comment}</p>
  </div>
</div>
{/foreach}
<!-- .comment -->
```

4. 在模板中显示评论数量

```php+HTML
<!--blogShow.html-->
<span>下发布</span>
<span class="post-comments">
  <i class="icon-speech-bubble"></i>
  <a href="#">{count($comments)}</a>
</span>
```





## **五、 项目完善**



### **1. 前台完善**



#### **1.1 首页评论数完善**



1. 在前台获取博文的时候，获取博文对应的评论数：直接修改获取博文的SQL指令

```PHP
#ArticleModel::getAllArticles

public function getAllArticles(array $cond = array(),int $pagecount = 5,int $page = 1){
        //构造基础条件where：所有查询出来的结果应该都是未“删除”的
        $where = ' where a_is_delete = 0 ';

        //判定条件：如果条件存在则增加一个条件选项
        foreach($cond as $k => $v){
            //判定字段，根据不同字段来制定方案
            switch($k){
                case 'a_title':
                    $where .= " and a_title like '%{$v}%'";
                    break;
                case 'c_id':
                    //都是使用=符号进行条件筛选，可以统一用
                    $where .= " and {$k} = {$v}";
                    break;
            }
        }

        //计算分页信息
        $offset = ($page - 1) * $pagecount;

        //构造完整SQL：获取博文的id，标题，内容，作者名字，图片，发布时间和分类名字（补充评论数）
        $sql = "select a.id,a.a_title,a.a_author,a.time,c.c_name,ct.c_count 
        from {$this->getTable()} a 
        left join {$this->getTable('category')} c 
        on a.c_id = c.id 
        left join (select a_id,count(*) c_count from {$this->getTable('comment')} group by a_id) ct
        on a.id = ct.a_id
        {$where} 
        order by a_time desc 
        limit {$offset},{$pagecount}";

        //执行SQL
        return $this->query($sql,true);
    }

```

2. 在首页模板中显示评论数，并增加评论链接进入详情页面

```php+HTML
<!--blogShowList.html-->
<span class="post-comments">
  <i class="icon-speech-bubble"></i>
  <a href="#">{$art.c_count}</a>
</span>
```





#### **1.2 博文详情页完善**



1. 实现博文首页链接跳转

```php+HTML
<!--blogShow.html-->
<div class="topbar">
  <div class="container">
    <a href="index.php" class="site-logo">
      博文前台
    </a><!-- .site-logo -->
  </div><!-- .container -->
</div><!-- .topbar -->
```



### **2. 后台完善**



#### **2.1 后台菜单栏链接完善**



1. 快速按钮链接：新增博文和直达前台

```php+HTML
<!--header.html-->
<div id="quickmenu">
    <a href="index.php?p=admin&c=article&a=add" class="qbutton-left tips" title="新增一篇博客"><img src="{P}/img/icons/header/newpost.png" width="18" height="14" alt="new post" /></a>
    <a href="index.php" class="qbutton-right tips" title="直达前台"><img src="{P}/img/icons/sidemenu/magnify.png" width="18" height="14" alt="new post" /></a>
    <div class="clear"></div>
</div>
```

2. 控制面板链接

```php+HTML
<!--sidebar.html-->
<li class="active"><a href="index.php?p=admin"><img src="{P}/img/icons/sidemenu/laptop.png" width="16" height="16" alt="icon"/>控制面板</a></li>
```



#### **2.2 分类管理完善**



1. 分类显示分类下所有的博文数量

   1.1修改分类获取的模型SQL指令：增加博文数量字段

   ```PHP
   #CategoryModel::getAllCategories()
   
   //获取所有分类信息：根据排序降序排序（数值越大，排序越高）
   $sql = "select c.*,a.a_count from {$this->getTable()} c
   	left join (select c_id,count(*) a_count from {$this->getTable('article')} group by c_id) a
   	on c.id = a.c_id
   	order by c.c_sort desc";
   ```

   1.2 修改模板显示数据

   ```php+HTML
   <!--categoryIndex.html-->
   {foreach $smarty.session.categories as $cat}
   <tr>
       <td>{$cat.c_id}</td>
       <!--利用PHP函数str_repeat()来实现'--'的重复-->
       <td>{str_repeat('--',$cat['level'] * 2)}{$cat.c_name}</td>
       <td>{$cat.a_count|default:0}</td>
       <td>{$cat.c_sort}</td>
       <td>
           <a href="index.php?p=admin&c=category&a=edit&id={$cat.id}">编辑</a>
           <a href="index.php?p=admin&c=category&a=delete&id={$cat.id}">删除</a>
       </td>
   </tr>
   {/foreach}
   ```

2. 修改分类删除逻辑：如果有博文不能删除，在分类删除方法内增加验证

   2.1分类控制器删除方法中增加可删除判定

   ```PHP
   #CategoryController::delete()
   
   //验证是否可删除：是否已经拥有博文（后续博文实现后完成）
   $a = new \admin\model\ArticleModel();
   if($a->checkArticleByCategory($id)){
       $this->error('当前分类下有博文关联，不能删除','index');
   }
   ```

   2.2 在博文模型下增加方法，验证分类是否有博文的

   ```PHP
   #ArticleModel::checkArticleByCategory()
   
   //根据分类ID获取博文信息
   public function checkArticleByCategory(int $c_id){
       $sql = "select id from {$this->getTable()} where c_id = {$c_id}";
       return $this->query($sql);
   }
   ```



#### 2.3 **后台评论功能**

1. 评论列表功能

   1.1增加菜单链接：sidebar.html

   ```php+HTML
   <!--sidebar.html-->
   <!-- 评论管理 -->
   <li><a href="index.php?p=admin&c=comment"><img src="{P}/img/icons/sidemenu/file.png" width="16" height="16" alt="icon"/>评论列表</a></li>
   <!-- 评论管理 -->
   ```

   1.2 增加控制器和处理方法，获取所有评论，并分配给模板：CommentController::index()

   ```PHP
   #CommentController.php
   namespace admin\controller;
   use \core\Controller;
   
   class CommentController extends Controller{
       
       //显示所有评论
       public function index(){
           //获取所有评论
           $c = new \admin\model\CommentModel();
           $comments = $c->getAllComments();
           
           //分配
           $this->assign('comments',$comments);
           $this->display('commentIndex.html');
       }
   }
   ```

   1.3 增加模型和方法，获取所有评论：包括评论本身信息以及文章标题、用户名

   ```PHP
   #CommentModel.php
   namespace admin\model;
   use \core\Model;
      
   class CommentModel extends Model{
          
       /* 
        * 获取评论信息
        * @param1 int $pagecount = 5，每次获取的数量
        * @param2 int $page = 1，分页页码
        */
       public function getAllComments(int $pagecount = 5,int $page = 1){
           //计算分页
           $offset = ($page - 1) * $pagecount;
             
           //组织SQL
           $sql = "select c.*,u.u_username,a.a_title from 
            {$this->getTable()} c 
            left join 
            {$this->getTable('article')} a on c.a_id = a.id
            left join
            {$this->getTable('user')} u on c.u_id = u.id
            order by c.c_time desc,c.a_id desc
            limit {$offset},{$pagecount}";
             
           //执行
           return $this->query($sql,true);
       }
   }
   ```

   1.4 在模板中显示所有的评论信息

   ```php+HTML
   <!--commentIndex.html-->
   {foreach $comments as $comment}
   <tr>
       <td>{$comment@key+1}</td>
       <td>{$comment.u_username}</td>
       <td>{$comment.c_comment}</td>
       <td><a href="index.php?a=detail&b_id={$comment.a_id}" target="_blank">{$comment.a_title}</a></td>
       <td>{date('Y-m-d',$comment.c_time)}</td>
       <td>
            <a href="#">删除</a>
       </td>
   </tr>
   {/foreach}
   ```

2. 后台评论分页功能

   2.1控制器接收分页信息

   ```PHP
   #CommentController::index()
   
   //接收分页数据：最开始
   $page = $_REQUEST['page'] ?? 1;
   global $config;
   $pagecount = $config['admin']['comment_pagecount'] ?? 5;
   ```

   2.2 获取总记录数

   ```PHP
   #CommentController::index()
   
   //获取评论之后
   $counts = $c->getCounts();
   ```
   2.3 模型中获取记录数

   ```PHP
   #CommentModel::getCounts()
   
   //获取评论数量
   public function getCounts(){
       $sql = "select count(*) c from {$this->getTable()}";
       $res = $this->query($sql);
       return $res['c'] ?? 0;
   }
   ```

   2.4 修改获取评论的方法条件

   ```PHP
   #CommentController::index()
   
   //修改获取评论的方法
   $comments = $c->getAllComments($pagecount,(int)$page);
   ```

   2.5 调用分页工具获取分页链接

   ```PHP
   #CommentController::index()
      
   //调用分页工具：显示模板之前
   $cond = array('a' => A,'c' => C,'p' => P);
   $pagestr = \vendor\Page::clickPage(URL . 'index.php',$counts,$pagecount,$page,$cond);
   //分配
   $this->assign('pagestr',$pagestr);
   ```

    2.6 在模板中显示分页链接

   ```PHP
   <!--commentIndex.html-->
   <ul class="pagination">
       {$pagestr}
   </ul>
   ```

3. 后台评论功能删除

   3.1 在列表页中，为所有的评论增加删除链接

   ```php+HTML
   <!--commentIndex.html-->
   {foreach $comments as $comment}
   <tr>
       <td>{$comment@key+1}</td>
       <td>{$comment.u_username}</td>
       <td>{$comment.c_comment}</td>
       <td><a href="index.php?a=detail&b_id={$comment.a_id}" target="_blank">{$comment.a_title}</a></td>
       <td>{date('Y-m-d',$comment.c_time)}</td>
       <td>
           <a href="index.php?p=admin&c=comment&a=delete&id={$comment.id}">删除</a>
       </td>
   </tr>
   {/foreach}
   ```

   3.2 在控制器中增加删除方法，实现删除功能

   ```PHP
   #CommentController::delete()
   
   //删除评论
   public function delete(){
       //接收数据
       $id = (int)$_GET['id'];
       
       //调用模型删除
       $c = new \admin\model\CommentModel();
       if($c->deleteById($id)){
           $this->success('删除成功！','index');
       }else{
           $this->error('删除失败！','index');
       }
   }
   ```